# reader_process.py

import time
import redis
import pytz
import pyodbc
from datetime import datetime
from cpppo.server.enip.get_attribute import proxy_simple
from multiprocessing import Process, current_process
from get_ips_from_sql import fetch_ip_list  # This function must return a list of IPs

# Constants
REAL_INDICES = [1, 4, 7, 10, 13, 16]
UINT_INDICES = [4, 10, 16, 22, 28, 34]
REDIS_HASH = 'controller_data'

# SQL connection string
SQL_CONN_STR = (
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=TGTCNWS904;'
    'DATABASE=taco_treceability_ir;'
    'UID=user_mis;'
    'PWD=admin'
)


def get_formatted_timestamp():
    utc_time = datetime.utcnow()
    ist = pytz.timezone('Asia/Kolkata')
    local_time = utc_time.replace(tzinfo=pytz.utc).astimezone(ist)
    return local_time.strftime('%Y-%m-%d %H:%M:%S')


def extract_selected_values(full_list, indices):
    return [full_list[i] for i in indices if i < len(full_list)]


def update_sql(ip, gun_number, torque, angle, timestamp):
    """
    Updates the SQL database and returns True if successful.
    """
    try:
        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()
        received_data = f"{torque},{angle}"
        cursor.execute("""
            UPDATE taco_treceability.ir_controller_configuration
            SET Received_Data = ?, Date_Time = ?
            WHERE controller_ip = ? AND gun = ?
        """, (received_data, timestamp, ip, gun_number))
        conn.commit()
        cursor.close()
        conn.close()
        print(f"[SQL] [OK] Updated IP {ip}, Gun {gun_number} â†’ {received_data} at {timestamp}")
        return True
    except Exception as sql_err:
        print(f"[SQL] [ERROR] Error updating DB for IP {ip}, Gun {gun_number}: {sql_err}")
        return False


def enip_reader(ip):
    print(f"[{current_process().name}] [OK] Reader started for {ip}")
    last_values = {}

    while True:
        try:
            with proxy_simple(ip, timeout=3) as via:
                print(f"[{ip}] [OK] Connected")

                r = redis.Redis(host='localhost', port=6379, db=0)

                while True:
                    try:
                        real_value, = via.read([('@4/100/3', 'REAL')])
                        uint_value, = via.read([('@4/100/3', 'UINT')])

                        real_selected = extract_selected_values(real_value, REAL_INDICES)
                        uint_selected = extract_selected_values(uint_value, UINT_INDICES)
                        timestamp = get_formatted_timestamp()

                        gun_entries = []
                        redis_update_needed = False

                        for i in range(min(len(real_selected), len(uint_selected))):
                            torque = real_selected[i]
                            angle = uint_selected[i]
                            gun_id = f"gun_{i+1}"
                            current_pair = (torque, angle)

                            # Check for data change
                            if last_values.get(i) != current_pair:
                                last_values[i] = current_pair
                                redis_update_needed = True

                                # Update SQL
                                success = update_sql(ip, i + 1, torque, angle, timestamp)

                                # If SQL acknowledged, delete Redis record for that IP
                                if success:
                                    r.hdel(REDIS_HASH, ip)
                                    print(f"[{ip}] [OK] Deleted Redis record after SQL update")

                                gun_entries.append(
                                    f'"{gun_id}": {{"torque": {torque}, "angle": {angle}, "timestamp": "{timestamp}"}}'
                                )

                        # Update Redis only if any change occurred
                        if redis_update_needed:
                            redis_json = f'{{"ip": "{ip}", "guns": {{{", ".join(gun_entries)}}}}}'
                            r.hset(REDIS_HASH, ip, redis_json)
                            print(f"[{ip}] [OK] Data updated in Redis and SQL")
                        else:
                            print(f"[{ip}] [INFO] No gun data changed")

                        time.sleep(2)  # Adjustable delay between reads

                    except Exception as read_err:
                        print(f"[{ip}] [ERROR] Read error: {read_err}")
                        break  # Exit inner loop to reconnect

        except Exception as conn_err:
            print(f"[{ip}] [ERROR] Connection error: {conn_err}")

        print(f"[{ip}] [INFO] Reconnecting after 5 seconds...")
        time.sleep(5)


def main():
    processes = {}
    print("[INFO] Monitoring IP list and managing reader processes...")

    try:
        while True:
            current_ips = set(fetch_ip_list())
            tracked_ips = set(processes.keys())

            # Start new readers
            for ip in current_ips - tracked_ips:
                print(f"[INFO] Starting ENIP reader for IP: {ip}")
                p = Process(target=enip_reader, args=(ip,), name=f"Reader-{ip}")
                p.start()
                processes[ip] = p

            # Stop removed IP readers
            for ip in tracked_ips - current_ips:
                print(f"[STOP] IP {ip} removed from DB. Terminating process.")
                processes[ip].terminate()
                processes[ip].join()
                del processes[ip]

            # Restart dead readers
            for ip in list(processes.keys()):
                if not processes[ip].is_alive():
                    print(f"[WARNING] Process for IP {ip} has stopped unexpectedly. Restarting.")
                    p = Process(target=enip_reader, args=(ip,), name=f"Reader-{ip}")
                    p.start()
                    processes[ip] = p

            time.sleep(1)

    except KeyboardInterrupt:
        print("\n[STOP] Gracefully stopping all readers...")
        for p in processes.values():
            p.terminate()
            p.join()
        print("[OK] All processes terminated.")

    except Exception as e:
        print("[ERROR] Unexpected error in main process:", e)


if __name__ == "__main__":
    main()
