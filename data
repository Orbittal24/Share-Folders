import time
import redis
import pytz
import pyodbc
import requests
from datetime import datetime
from cpppo.server.enip.get_attribute import proxy_simple
from multiprocessing import Process, current_process, Event
from get_ips_from_sql import fetch_ip_list

# ------------------------------------------------------------------
# CONSTANTS
# ------------------------------------------------------------------

# Explicit gun → PLC index mapping (CRITICAL FIX)
GUN_MAP = {
    1: (1, 4),
    2: (4, 10),
    3: (7, 16),
    4: (10, 22),
    5: (13, 28),
    6: (16, 34),
}

REDIS_HASH = 'controller_data'

SQL_CONN_STR = (
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=TGTCNWS904;'
    'DATABASE=taco_treceability_ir;'
    'UID=user_mis;'
    'PWD=admin'
)

API_ENDPOINT = 'https://misapp.tataautocomp.com:3241/trigger_nomenclature_fetch'

# ------------------------------------------------------------------
# UTILS
# ------------------------------------------------------------------
def get_formatted_timestamp():
    utc_time = datetime.utcnow()
    ist = pytz.timezone('Asia/Kolkata')
    local_time = utc_time.replace(tzinfo=pytz.utc).astimezone(ist)
    return local_time.strftime('%Y-%m-%d %H:%M:%S')

# ------------------------------------------------------------------
# PROCESS LOOKUP
# ------------------------------------------------------------------
def find_process_record(conn, controller_ip, gun):
    cursor = conn.cursor()
    queries = [
        """
        SELECT TOP 1 Process_ID, Running_Count, Pack_ID, Angle_Array, Line
        FROM taco_treceability.Process_Register_master
        WHERE Torque_Array = ?
          AND CHARINDEX(',' + ?, ',' + Angle_Array + ',') > 0
        ORDER BY Process_ID DESC
        """,
        """
        SELECT TOP 1 Process_ID, Running_Count, Pack_ID, Angle_Array, Line
        FROM taco_treceability.TrayAssemblyBoltingCount_master
        WHERE Torque_Array = ? AND Angle_Array = ?
        ORDER BY Process_ID DESC
        """
    ]

    for query in queries:
        cursor.execute(query, controller_ip, str(gun))
        for row in cursor.fetchall():
            angles = [a.strip() for a in str(row.Angle_Array).split(',')]
            if str(gun) in angles:
                cursor.close()
                return {
                    "Process_ID": row.Process_ID,
                    "Running_Count": row.Running_Count,
                    "Pack_ID": row.Pack_ID,
                    "Line": row.Line
                }
    cursor.close()
    return None

# ------------------------------------------------------------------
# SQL + REDIS + API
# ------------------------------------------------------------------
def trigger_api_once(station_id, controller_ip, pack_id, gun, process_id, line_id, received_data):
    payload = {
        "station_id": station_id,
        "controller_ip": controller_ip,
        "pack_id": pack_id,
        "gun": gun,
        "process_id": process_id,
        "line_id": line_id,
        "Received_Data": received_data
    }
    print("payload", payload)

    try:
        response = requests.post(API_ENDPOINT, json=payload, timeout=10)
        if response.status_code == 200:
            print(f"[OK] API triggered for process_id {process_id}")
        else:
            print(f"[ERROR] API failed for process_id {process_id}, Status: {response.status_code}")
    except requests.exceptions.RequestException as e:
        print(f"[ERROR] API error: {e}")

def update_sql_redis_api(ip, gun, torque, angle, timestamp):
    try:
        conn = pyodbc.connect(SQL_CONN_STR)
        process = find_process_record(conn, ip, gun)

        if not process:
            print(f"[SQL] [SKIP] No process mapping for IP {ip}, Gun {gun}")
            conn.close()
            return

        received_data = f"{torque},{angle}"

        cursor = conn.cursor()
        cursor.execute("""
            UPDATE taco_treceability.ir_controller_configuration
            SET Received_Data = ?, Date_Time = ?
            WHERE controller_ip = ? AND gun = ? AND Process_ID = ?
              AND station_id = ? AND Pack_ID = ?
              AND (Received_Data <> ? OR Received_Data IS NULL)
        """, (
            received_data,
            timestamp,
            ip,
            gun,
            process["Process_ID"],
            process["Running_Count"],
            process["Pack_ID"],
            received_data
        ))

        updated = cursor.rowcount
        conn.commit()
        cursor.close()
        conn.close()

        if updated > 0:
            r = redis.Redis(host='localhost', port=6379, db=0)
            redis_json = (
                f'{{"ip":"{ip}","guns":{{"gun_{gun}":'
                f'{{"torque":{torque},"angle":{angle},"timestamp":"{timestamp}"}}}}}}'
            )
            r.hset(REDIS_HASH, ip, redis_json)

            trigger_api_once(
                process["Running_Count"],
                ip,
                process["Pack_ID"],
                gun,
                process["Process_ID"],
                process["Line"],
                received_data
            )

            print(f"[SQL] [OK] Updated IP {ip}, Gun {gun} → {received_data}")

    except Exception as e:
        print(f"[ERROR] {ip} Gun {gun}: {e}")

# ------------------------------------------------------------------
# ENIP READER
# ------------------------------------------------------------------
def enip_reader(ip, stop_event):
    print(f"[{current_process().name}] Reader started for {ip}")
    last_values = {}
    retry_delay = 5

    while not stop_event.is_set():
        try:
            with proxy_simple(ip, timeout=3) as via:
                print(f"[{ip}] Connected")
                retry_delay = 5

                while not stop_event.is_set():
                    try:
                        real_value, uint_value = via.read([
                            ('@4/100/3', 'REAL'),
                            ('@4/100/3', 'UINT'),
                        ])

                        timestamp = get_formatted_timestamp()

                        for gun_no, (real_idx, uint_idx) in GUN_MAP.items():
                            if real_idx >= len(real_value) or uint_idx >= len(uint_value):
                                print(f"[WARN] {ip} Gun {gun_no} missing PLC data")
                                continue

                            torque = real_value[real_idx]
                            angle = uint_value[uint_idx]

                            current_pair = (torque, angle)

                            if last_values.get(gun_no) != current_pair:
                                last_values[gun_no] = current_pair
                                update_sql_redis_api(ip, gun_no, torque, angle, timestamp)

                        time.sleep(1)

                    except Exception as e:
                        print(f"[{ip}] Read error: {e}")
                        break

        except Exception as e:
            print(f"[{ip}] Connection error: {e}")
            time.sleep(retry_delay)
            retry_delay = min(retry_delay * 2, 60)

    print(f"[{ip}] Reader stopped cleanly")

# ------------------------------------------------------------------
# MAIN
# ------------------------------------------------------------------
def main():
    processes = {}
    stop_event = Event()

    print("[INFO] Monitoring IP list...")

    try:
        while True:
            current_ips = set(fetch_ip_list())
            tracked_ips = set(processes.keys())

            for ip in current_ips - tracked_ips:
                print(f"[START] Reader for {ip}")
                p = Process(target=enip_reader, args=(ip, stop_event), name=f"Reader-{ip}")
                p.start()
                processes[ip] = p

            for ip in tracked_ips - current_ips:
                print(f"[STOP] IP removed {ip}")
                processes[ip].terminate()
                processes[ip].join()
                del processes[ip]

            for ip, p in list(processes.items()):
                if not p.is_alive():
                    print(f"[RESTART] Reader died for {ip}")
                    np = Process(target=enip_reader, args=(ip, stop_event), name=f"Reader-{ip}")
                    np.start()
                    processes[ip] = np

            time.sleep(1)

    except KeyboardInterrupt:
        print("\n[STOP] Gracefully stopping readers...")
        stop_event.set()
        for p in processes.values():
            p.join()
        print("[OK] All readers stopped cleanly")

if __name__ == "__main__":
    main()
