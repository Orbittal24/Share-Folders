@router.post("/torque_api_normal")
async def trigger_nomenclature_fetch(
    payload: dict = Body(...),
    db: Session = Depends(get_ir_db),
    master_db: Session = Depends(get_MASTER_IR_db)
):
    try:
        # ---------------------------------------------------
        # Extract & validate payload
        # ---------------------------------------------------
        pack_id = payload.get("pack_id")
        process_id = payload.get("process_id")
        line_id = payload.get("line_id")
        station_id = payload.get("station_id")
        received_data = payload.get("Received_Data")
        print(f"Received Payload: {payload}")

        if None in (pack_id, process_id, line_id, station_id, received_data):
            raise HTTPException(status_code=400, detail="Missing required fields")

        try:
            torque_str, angle_str = received_data.split(",")
            torque = round(float(torque_str), 2)
            angle = round(float(angle_str), 2)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid Received_Data format")

        # ---------------------------------------------------
        # Fetch torque / angle range (DB instead of API)
        # ---------------------------------------------------
        process = master_db.query(ProcessMaster).filter(
            ProcessMaster.Station_ID == station_id,
            ProcessMaster.Pack_ID == pack_id,
            ProcessMaster.Process_ID == process_id
        ).first()

        if not process:
            raise HTTPException(status_code=404, detail="Process not found")

        def parse_range(val: str):
            low, high = map(float, val.replace("Nm", "").replace("°", "").split("-"))
            return low, high

        torque_min, torque_max = parse_range(process.Torque_Range)
        angle_min, angle_max = parse_range(process.Angle_Range)

        if not (torque_min <= torque <= torque_max and angle_min <= angle <= angle_max):
            return {
                "message": "Torque or angle out of range",
                "torque": torque,
                "angle": angle,
                "expected_torque_range": f"{torque_min}-{torque_max}",
                "expected_angle_range": f"{angle_min}-{angle_max}",
                "skipped": True
            }

        # ===================================================
        # ELSE → NORMAL PROCESS REGISTER FLOW
        # ===================================================
        result = db.query(ProcessRegisterMaster).filter(
            ProcessRegisterMaster.Pack_ID == pack_id,
            ProcessRegisterMaster.Process_ID == process_id,
            ProcessRegisterMaster.Line == line_id,
            ProcessRegisterMaster.Running_Count == station_id
        ).order_by(ProcessRegisterMaster.srno.desc()).first()

        if not result or not result.Module_barcode:
            raise HTTPException(status_code=404, detail="Module barcode not found")

        module_barcode = result.Module_barcode

        # ---------------------------------------------------
        # fetch_nomenclature API (UNCHANGED, AS REQUESTED)
        # ---------------------------------------------------
        # async with httpx.AsyncClient(verify=SSL_PATH) as client:
        #     response = await client.get(f"{API_URL}/fetch_nomenclature/{module_barcode}")

        # if response.status_code != 200:
        #     raise HTTPException(status_code=502, detail="fetch_nomenclature failed")

        # nomenclature = response.json()[0]
        # pack_creation = nomenclature["Pack_creation_Date"].split("T")[0]
        
        formatted_date = datetime.strptime(result.Time, "%Y-%m-%d").strftime("%d-%m-%y")

        # ---------------------------------------------------
        # Dynamic process_register table (DB)
        # ---------------------------------------------------
        inspector = inspect(engine_ir)
        tables = inspector.get_table_names(schema="taco_treceability")

        table_name = next(
            (t for t in tables if t.lower().startswith(f"process_register_{formatted_date.lower()}")),
            None
        )

        if not table_name:
            raise HTTPException(status_code=404, detail="Process register table not found")

        Model = get_dynamic_model(
            table_name.replace("process_register_", "")
        )

        record = db.query(Model).filter(
            Model.Pack_ID == pack_id,
            Model.Process_ID == process_id,
            Model.Module_barcode == module_barcode
        ).first()

        if not record:
            raise HTTPException(status_code=404, detail="Process record not found")

        torque_arr = json.loads(record.Torque_Array or "[]")
        angle_arr = json.loads(record.Angle_Array or "[]")

        if record.Process_Status == "Completed":
            return {
                "message": "Process already completed",
                "Running_Count": record.Running_Count,
                "Target_Count": record.Target_Count
            }

        torque_arr.append(torque)
        angle_arr.append(angle)

        record.Running_Count += 1
        if record.Running_Count == record.Target_Count:
            record.Process_Status = "Completed"

        record.Torque_Array = json.dumps(torque_arr)
        record.Angle_Array = json.dumps(angle_arr)

        db.commit()

        # Delete master after completion (same logic)
        print("Process Status",record.Process_Status)
        if record.Process_Status == "Completed":
            db.query(ProcessRegisterMaster).filter(
                ProcessRegisterMaster.Pack_ID == pack_id,
                ProcessRegisterMaster.Process_ID == process_id,
                ProcessRegisterMaster.Line == line_id,
                ProcessRegisterMaster.Module_barcode == module_barcode,
                ProcessRegisterMaster.Running_Count == station_id
                
            ).delete(synchronize_session=False)
            db.commit()

        return {
            "message": "Process register updated successfully",
            "Torque_Array": torque_arr,
            "Angle_Array": angle_arr,
            "Running_Count": record.Running_Count,
            "Process_Status": record.Process_Status
        }

    except Exception as e:
        import traceback
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))
