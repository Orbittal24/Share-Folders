# reader_process.py

import time
import redis
import pytz
import pyodbc
from datetime import datetime
from cpppo.server.enip.get_attribute import proxy_simple
from multiprocessing import Process, current_process
from get_ips_from_sql import fetch_ip_list
import requests

# Constants
REAL_INDICES = [1, 4, 7, 10, 13, 16]
UINT_INDICES = [4, 10, 16, 22, 28, 34]
REDIS_HASH = 'controller_data'

# SQL connection string
SQL_CONN_STR = (
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=TGTCNWS904;'
    'DATABASE=taco_treceability_ir;'
    'UID=user_mis;'
    'PWD=admin'
)


def get_formatted_timestamp():
    utc_time = datetime.utcnow()
    ist = pytz.timezone('Asia/Kolkata')
    local_time = utc_time.replace(tzinfo=pytz.utc).astimezone(ist)
    return local_time.strftime('%Y-%m-%d %H:%M:%S')


def extract_selected_values(full_list, indices):
    return [full_list[i] for i in indices if i < len(full_list)]


# ðŸ”¹ NEW FUNCTION TO GET PROCESS_ID
def get_process_id(cursor):
    cursor.execute("""
        SELECT Process_ID
        FROM taco_treceability.Process_Register_master
        WHERE Torque_Array = '' AND Angle_Array = ''
    """)
    row = cursor.fetchone()
    if row:
        return row[0]

    cursor.execute("""
        SELECT Process_ID
        FROM taco_treceability.TrayAssemblyBoltingCount_master
        WHERE Torque_Array = '' AND Angle_Array = ''
    """)
    row = cursor.fetchone()
    if row:
        return row[0]

    return None


def poll_and_trigger(ip, gun_number, timestamp):
    API_ENDPOINT = 'https://misapp.tataautocomp.com:3241/trigger_nomenclature_fetch'
    last_seen = {}
    session = requests.Session()

    while True:
        try:
            conn = pyodbc.connect(SQL_CONN_STR)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT srno, station_id, controller_ip, pack_id, gun,
                       process_id, line_id, Received_Data, Date_Time
                FROM taco_treceability.ir_controller_configuration
                WHERE controller_ip = ?
                  AND gun = ?
                  AND Date_Time = ?
            """, (ip, gun_number, timestamp))

            rows = cursor.fetchall()

            for row in rows:
                srno, station_id, controller_ip, pack_id, gun, process_id, line_id, Received_Data, date_time = row

                if last_seen.get(srno) == date_time:
                    continue

                last_seen[srno] = date_time

                payload = {
                    "station_id": station_id,
                    "controller_ip": controller_ip,
                    "pack_id": pack_id,
                    "gun": gun,
                    "process_id": process_id,
                    "line_id": line_id,
                    "Received_Data": Received_Data
                }

                print("payload", payload)

                try:
                    response = session.post(API_ENDPOINT, json=payload, timeout=5)
                    if response.status_code == 200:
                        print(f"[OK] API triggered for srno {srno}")
                    else:
                        print(f"[ERROR] API failed for srno {srno}, Status: {response.status_code}")
                except requests.exceptions.RequestException as api_err:
                    print(f"[ERROR] API error for srno {srno}: {api_err}")

                time.sleep(0.2)

            cursor.close()
            conn.close()
            time.sleep(2)

        except Exception as e:
            print("[ERROR] Error polling table:", e)
            time.sleep(5)


def update_sql(ip, gun_number, torque, angle, timestamp):
    try:
        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()

        # ðŸ”¹ Fetch process_id before update
        process_id = get_process_id(cursor)

        if not process_id:
            print(f"[SQL] [WARNING] No process_id found for IP {ip}, Gun {gun_number}")
            cursor.close()
            conn.close()
            return

        received_data = f"{torque},{angle}"

        cursor.execute("""
            UPDATE taco_treceability.ir_controller_configuration
            SET Received_Data = ?, Date_Time = ?
            WHERE controller_ip = ?
              AND gun = ?
              AND process_id = ?
        """, (received_data, timestamp, ip, gun_number, process_id))

        conn.commit()
        cursor.close()
        conn.close()

        print(
            f"[SQL] [OK] Updated IP {ip}, Gun {gun_number}, "
            f"Process {process_id} â†’ {received_data} at {timestamp}"
        )

        poll_and_trigger(ip, gun_number, timestamp)

    except Exception as sql_err:
        print(f"[SQL] [ERROR] Error updating DB for IP {ip}, Gun {gun_number}: {sql_err}")


def enip_reader(ip):
    print(f"[{current_process().name}] [OK] Reader started for {ip}")
    last_values = {}

    while True:
        try:
            with proxy_simple(ip, timeout=3) as via:
                print(f"[{ip}] [OK] Connected")
                r = redis.Redis(host='localhost', port=6379, db=0)

                while True:
                    try:
                        real_value, = via.read([('@4/100/3', 'REAL')])
                        uint_value, = via.read([('@4/100/3', 'UINT')])

                        real_selected = extract_selected_values(real_value, REAL_INDICES)
                        uint_selected = extract_selected_values(uint_value, UINT_INDICES)
                        timestamp = get_formatted_timestamp()

                        gun_entries = []
                        redis_update_needed = False

                        for i in range(min(len(real_selected), len(uint_selected))):
                            torque = real_selected[i]
                            angle = uint_selected[i]
                            gun_id = f"gun_{i+1}"
                            current_pair = (torque, angle)

                            if last_values.get(i) != current_pair:
                                last_values[i] = current_pair
                                redis_update_needed = True

                                update_sql(ip, i + 1, torque, angle, timestamp)

                                gun_entries.append(
                                    f'"{gun_id}": {{"torque": {torque}, "angle": {angle}, "timestamp": "{timestamp}"}}'
                                )

                        if redis_update_needed:
                            redis_json = f'{{"ip": "{ip}", "guns": {{{", ".join(gun_entries)}}}}}'
                            r.hset(REDIS_HASH, ip, redis_json)
                            print(f"[{ip}] [OK] Data updated in Redis and SQL")
                        else:
                            print(f"[{ip}] [INFO] No gun data changed")

                        time.sleep(2)

                    except Exception as read_err:
                        print(f"[{ip}] [ERROR] Read error: {read_err}")
                        break

        except Exception as conn_err:
            print(f"[{ip}] [ERROR] Connection error: {conn_err}")

        print(f"[{ip}] [INFO] Reconnecting after 5 seconds...")
        time.sleep(5)


def main():
    processes = {}
    print("[INFO] Monitoring IP list and managing reader processes...")

    try:
        while True:
            current_ips = set(fetch_ip_list())
            tracked_ips = set(processes.keys())

            for ip in current_ips - tracked_ips:
                print(f"[INFO] Starting ENIP reader for IP: {ip}")
                p = Process(target=enip_reader, args=(ip,), name=f"Reader-{ip}")
                p.start()
                processes[ip] = p

            for ip in tracked_ips - current_ips:
                print(f"[STOP] IP {ip} removed from DB. Terminating process.")
                processes[ip].terminate()
                processes[ip].join()
                del processes[ip]

            for ip in list(processes.keys()):
                if not processes[ip].is_alive():
                    print(f"[WARNING] Process for IP {ip} stopped. Restarting.")
                    p = Process(target=enip_reader, args=(ip,), name=f"Reader-{ip}")
                    p.start()
                    processes[ip] = p

            time.sleep(1)

    except KeyboardInterrupt:
        print("\n[STOP] Gracefully stopping all readers...")
        for p in processes.values():
            p.terminate()
            p.join()
        print("[OK] All processes terminated.")

    except Exception as e:
        print("[ERROR] Unexpected error in main process:", e)


if __name__ == "__main__":
    main()
