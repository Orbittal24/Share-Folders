const sql = require('mssql');
const axios = require('axios');
const stringSimilarity = require('string-similarity');

const sqlConfig1 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig2 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability_master",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig3 = {
  user: "user_mis",
  password: "admin",
  database: "master_taco_treceability_IR",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

let lastSeenSrNo = 0;
let pool1, pool2, pool3;

// --------------------- Utilities ---------------------
const normalizeProcess = (text) =>
  text.toLowerCase()
      .replace(/[^a-z0-9+\/\-()& ]/g, '') // preserve special chars
      .replace(/\s+/g, ' ')
      .trim();

const getCommonWordsScore = (a, b) => {
  const setA = new Set(a.split(' '));
  const setB = new Set(b.split(' '));
  const common = [...setA].filter(w => setB.has(w));
  return common.length / Math.max(setA.size, setB.size);
};

const normalizeModuleNumber = (str) => str.replace(/^0+/, '').toLowerCase();

const uniqueProcesses = [
  "BDU -ve to HV -ve busbar (18.4)",
  "BDU -ve to HV -ve busbar (21.3)",
  "BDU to M3 +ve busbar (18.4)",
  "BDU to M3 +ve busbar (21.3)",
  "BMS bracket installation (18.4)",
  "BMS bracket installation (21.3)",
  "BMS to BMS bracket installation (18.4)",
  "BMS to BMS bracket installation (21.3)",
  "Breather plug 1 (18.4)",
  "Breather plug 1 (21.3)",
  "C plate fixing plate installation (18.4)",
  "C plate fixing plate installation (21.3)",
  "Exposion proof valve (18.4)",
  "Exposion proof valve (21.3)",
  "HV +ve to relay busbar (18.4)",
  "HV +ve to relay busbar (21.3)",
  "HV -ve to BDU -ve busbar (18.4)",
  "HV -ve to BDU -ve busbar (21.3)",
  "L plate bracket (18.4)",
  "L plate bracket (21.3)",
  "LV to ground (18.4)",
  "LV to ground (21.3)",
  "Module fixing (18.4)",
  "Module fixing (21.3)",
  "Module plate tie rod assembly (18.4)",
  "Module plate tie rod assembly (21.3)",
  "Module side plate to L bracket (18.4)",
  "Module side plate to L bracket (21.3)",
  "Module to busbar install M1 +ve to shunt (18.4)",
  "Module to busbar install M1 +ve to shunt (21.3)",
  "Module to busbar install M1 to M2 (18.4)",
  "Module to busbar install M1 to M2 (21.3)",
  "Module to busbar install M2 +ve to HV MSD +ve (18.4)",
  "Module to busbar install M2 +ve to HV MSD +ve (21.3)",
  "Module to busbar install M3 +ve to BDU +ve (18.4)",
  "Module to busbar install M3 +ve to BDU +ve (21.3)",
  "Module to busbar install M3 -ve to HV MSD -ve (18.4)",
  "Module to busbar install M3 -ve to HV MSD -ve (21.3)",
  "MSD +ve to M2 +ve busbar (18.4)",
  "MSD +ve to M2 +ve busbar (21.3)",
  "MSD -ve to M3 -ve busbar (18.4)",
  "MSD -ve to M3 -ve busbar (21.3)",
  "Relay -ve to HV +ve and main -ve (18.4)",
  "Relay -ve to HV +ve and main -ve (21.3)",
  "Relay to shunt busbar (18.4)",
  "Relay to shunt busbar (21.3)",
  "Shunt to M1 -ve busbar (18.4)",
  "Shunt to M1 -ve busbar (21.3)",
  "Shunt to relay busbar (18.4)",
  "Shunt to relay busbar (21.3)",
  "Side bracket self tapping lower (18.4)",
  "Side bracket self tapping lower (21.3)",
  "Side bracket self tapping upper (18.4)",
  "Side bracket self tapping upper (21.3)",
  "Tray cover fitment (18.4)",
  "Tray cover fitment (21.3)",
];

// --------------------- Initialization ---------------------
const init = async () => {
  try {
    pool1 = await new sql.ConnectionPool(sqlConfig1).connect();
    console.log("Connected to taco_treceability");

    pool2 = await new sql.ConnectionPool(sqlConfig2).connect();
    console.log("Connected to taco_treceability_master");

    pool3 = await new sql.ConnectionPool(sqlConfig3).connect();
    console.log("Connected to master_taco_treceability_IR");

    startFetchLoop();
  } catch (err) {
    console.error("Error connecting to databases:", err);
  }
};

// --------------------- Fetch & Process ---------------------
const startFetchLoop = async () => {
  try {
    const processListSQL = uniqueProcesses.map(p => `'${p.replace(/'/g, "''")}'`).join(',');

    const result = await pool1.request().query(`
      SELECT TOP(1) sr_no, pack_name, module_name, module_barcode, torque, angle,
             process_name, date_dd, pack_no, smoke_sensor_linked_pack_no, bypass_operator
      FROM taco_treceability.torque_details_EIP_mirror
      WHERE sr_no > ${lastSeenSrNo}
        AND pack_name IN ('Ejeeto 18.4','Ejeeto 21.3')
        AND process_name IN (${processListSQL})
      ORDER BY sr_no ASC
    `);

    if (!result.recordset.length) {
      console.log('No new rows found.');
      return setTimeout(startFetchLoop, 3000);
    }

    for (const row of result.recordset) {
      console.log('Processing row:', row);

      const processedPackNo = row.pack_no === 'not_linked' ? 'not_linked' : row.pack_no.slice(-6);

      const packRes = await pool2.request().query(`
        SELECT Pack_ID FROM taco_treceability.master_pack
        WHERE Pack_Name='${row.pack_name}'
      `);

      if (!packRes.recordset.length) {
        console.log('Pack_ID not found for', row.pack_name);
        continue;
      }

      const packID = packRes.recordset[0].Pack_ID;

      let scanType, scanID, moduleName, modulebarQR;

      if (!row.smoke_sensor_linked_pack_no || row.smoke_sensor_linked_pack_no.toLowerCase() === 'null') {
        const modRes = await pool2.request().query(`
          SELECT Module_Name, Module_ID FROM taco_treceability.master_module
          WHERE moduleNumber='${row.module_name}' AND Pack_ID='${packID}'
        `);

        if (!modRes.recordset.length) {
          console.log('Module not found for', row.module_name);
          continue;
        }

        scanType = 'Module';
        scanID = modRes.recordset[0].Module_ID;
        moduleName = modRes.recordset[0].Module_Name;
      } else {
        const bomRes = await pool2.request().query(`
          SELECT BOM_ID FROM taco_treceability.BOM_Master
          WHERE BOM_Name='Smoke sensor' AND Pack_ID='${packID}'
        `);
        if (!bomRes.recordset.length) {
          console.log('BOM not found for Smoke sensor');
          continue;
        }
        scanType = 'BOM';
        scanID = bomRes.recordset[0].BOM_ID;
      }

      if (row.module_barcode.startsWith('DJ')) {
        const qrRes = await pool1.request().query(`
          SELECT CustomerQRCode FROM taco_treceability.final_qrcode_details
          WHERE final_qrcode='${row.pack_no}'
        `);
        if (!qrRes.recordset.length) {
          console.log('QR code not found for pack_no', row.pack_no);
          continue;
        }
        scanType = 'Pack';
        modulebarQR = qrRes.recordset[0].CustomerQRCode;
      }

      // Fetch process master entries
      const [pmRes, pmResPack, pmResBom] = await Promise.all([
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_ID='${scanID}'
        `),
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_ID='${packID}' AND Scan_Name='Pack'
        `),
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_Name='BOM'
        `),
      ]);

      // ---------------- Module Logic ----------------
      let best = { score:0, processID:null, totalCount:null, scanName:null, processName:'' };
      let best1 = {...best}, best2 = {...best};

      if (scanType === 'Module') {
        console.log('Module processing:', row.process_name, moduleName);

        if (!pmRes.recordset.length) {
          console.log('No process master rows for module', moduleName);
          continue;
        }

        const inputNorm = normalizeProcess(row.process_name);
        const modKey = normalizeModuleNumber(moduleName);

        for (const p of pmRes.recordset) {
          const raw = p.Process_Name.toLowerCase();
          const needsModuleMatch = /\bM\d+\b/i.test(p.Process_Name);

          if (needsModuleMatch && !raw.includes(`m${modKey}`)) {
            console.log('Skipped due to module mismatch:', p.Process_Name);
            continue;
          }

          const cand = normalizeProcess(p.Process_Name);
          if (inputNorm === cand) {
            best = { 
              score: 1,
              processID: p.Process_ID,
              totalCount: p.Total_Count,
              scanName: p.Scan_Name,
              processName: p.Process_Name
            };
            console.log('Exact match found:', best);
            break;
          }
        }

        if (!best.processID) {
          console.log('No matching process found for module', moduleName);
          continue;
        }
      }

      // ---------------- Pack Logic ----------------
      if (scanType === 'Pack') {
        console.log('Pack processing:', row.process_name);
        if (!pmResPack.recordset.length) {
          console.log('No process master rows for pack');
          continue;
        }

        const inputNorm = normalizeProcess(row.process_name);
        const inputRaw = row.process_name.toLowerCase();
        const arr = [];

        for (const p of pmResPack.recordset) {
          const raw = p.Process_Name.toLowerCase();
          const cand = normalizeProcess(p.Process_Name);

          let score = 0;
          if (inputRaw === raw) score = 1;
          else if (raw.startsWith(inputRaw)) score = 0.99;
          else if (raw.includes(inputRaw)) score = 0.95;
          else if (inputRaw.includes(raw)) score = 0.9;
          else {
            score = 0.7 * getCommonWordsScore(inputNorm, cand) +
                    0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);
          }

          arr.push({ score, processID: p.Process_ID, totalCount: p.Total_Count, scanName: p.Scan_Name, processName: p.Process_Name });
        }

        arr.sort((a,b) => b.score - a.score || a.processName.length - b.processName.length);
        best1 = arr[0];
        if (!best1.processID || best1.score < 0.5) {
          console.log('No matching process found for pack');
          continue;
        }
      }

      // ---------------- BOM Logic ----------------
      if (scanType === 'BOM') {
        const inputWords = row.process_name.match(/[\w()+\-\/&]+/g); 
        if (!inputWords || inputWords.length === 0) continue;

        const matches = [];
        for (const p of pmResBom.recordset) {
          const processWords = p.Process_Name.match(/[\w()+\-\/&]+/g) || [];
          const allMatch = inputWords.every(word => processWords.includes(word));
          if (allMatch) {
            matches.push({
              score: 1,
              processID: p.Process_ID,
              totalCount: p.Total_Count,
              scanName: p.Scan_Name,
              processName: p.Process_Name
            });
          }
        }

        matches.sort((a, b) => b.score - a.score || a.processName.length - b.processName.length);
        best2 = matches[0];

        if (!best2?.processID || best2.score < 0.5) {
          console.log('No matching process found for BOM');
          continue;
        }
      }

      // ---------------- API Logic ----------------
      // Module, Pack, BOM API calls
      // (Here you can copy your existing axios.post code exactly)

      if (row.sr_no > lastSeenSrNo) lastSeenSrNo = row.sr_no;
    }

    setTimeout(startFetchLoop, 3000); // continue loop
  } catch (err) {
    console.error("Error fetching or processing rows:", err);
    setTimeout(startFetchLoop, 5000);
  }
};

init();
