const { Console } = require("console");

module.exports = {
    includeCode: function (io, sql, sqlConfig) {

        // üî• Prevent duplicate loading
        if (global.__includeCodeLoaded__) {
            console.log("‚ùå includeCode already loaded, skipping...");
            return;
        }
        global.__includeCodeLoaded__ = true;
        console.log("üî• includeCode LOADED FIRST TIME ONLY");

        const path = require("path");
        const net = require('net');
        const multer = require("multer");
        const bodyParser = require('body-parser');
        const WebSocketServer = require('websocket').server;
        const http = require("http");
        const events = require('events');
        const em = new events.EventEmitter();
        const express = require("express");
        const app = express();
        const util = require("util");
        const fs = require("fs");
        const moment = require('moment');

        app.use(bodyParser.json({ limit: '16mb' }));
        app.use(bodyParser.urlencoded({ extended: false, limit: '16mb' }));
        app.use(express.static(__dirname));

        // ‚úÖ Single SQL pool for all queries
        const poolPromise = new sql.ConnectionPool(sqlConfig)
            .connect()
            .then(pool => {
                console.log("‚úÖ SQL Pool connected");
                return pool;
            })
            .catch(err => console.log("‚ùå SQL Pool connection error:", err));

        // This function create and return a net.Socket object to represent TCP client.
        function getConn(connName) {
            const option = { host: '127.0.0.1', port: 3306 };
            const client = net.createConnection(option, function () {
                console.log('Connection name : ' + connName);
                console.log('Connection local address : ' + client.localAddress + ":" + client.localPort);
                console.log('Connection remote address : ' + client.remoteAddress + ":" + client.remotePort);
            });
            client.setTimeout(1000);
            client.setEncoding('utf8');

            client.on('data', function (data) {
                console.log('Server return data : ' + data);
            });
            client.on('end', function () { console.log('Client socket disconnect.'); });
            client.on('timeout', function () { console.log('Client connection timeout.'); });
            client.on('error', function (err) { console.error(JSON.stringify(err)); });

            return client;
        }

        const HOST = '127.0.0.1';
        const PORT = 3306;
        global.MYVAR = "connected!";
        global.MYVAR2 = "connected!";
        const server = net.createServer();

        io.sockets.on("connection", function (socket) {

            // Prevent attaching listeners multiple times per socket
            if (socket.__listenersAdded__) return;
            socket.__listenersAdded__ = true;

            socket.on('callread', function (msg) {
                MYVAR = msg;
                for (var i = 0; i < sockets.length; i++) {
                    if (sockets[i]) {
                        sockets[i].write(MYVAR, 'utf-8');
                    }
                }
            });

            /////////////////////////////// OK DATA

            socket.removeAllListeners('date_selected_searchdata_count_OK');
            socket.on('date_selected_searchdata_count_OK', async (date) => {
                console.log("Received date from client IRRRR search count:", date);

                const final_qrcode_arr_eip_count = [];
                try {
                    const pool = await poolPromise;
                    const query = `
                        SELECT DISTINCT pack_no 
                        FROM taco_treceability.torque_details_EIP 
                        WHERE CONVERT(varchar(200), date_dd) < '${date}' 
                          AND pack_no != 'not_linked'
                    `;
                    const result = await pool.request().query(query);
                    result.recordset.forEach(row => final_qrcode_arr_eip_count.push(row.pack_no));

                    const collectedFinalQRCodes_count = [];
                    for (const packNo of final_qrcode_arr_eip_count) {
                        const safePackNo = packNo.replace(/'/g, "''");
                        const innerQuery = `
                            SELECT DISTINCT FinalQRCode 
                            FROM taco_treceability.station_status 
                            WHERE FinalQRCode LIKE '%${safePackNo}%' 
                              AND FinalQRCodePrint_status = 'OK'
                        `;
                        const innerResult = await pool.request().query(innerQuery);
                        if (innerResult.recordset.length > 0) {
                            const foundCodes = innerResult.recordset.map(r => r.FinalQRCode);
                            collectedFinalQRCodes_count.push(...foundCodes);
                        }
                    }

                    console.log("Final QRCodes from station_status ok:", collectedFinalQRCodes_count);

                    let totalCount = 0;
                    for (const finalQRCode of collectedFinalQRCodes_count) {
                        const safeQRCode = finalQRCode.replace(/'/g, "''");
                        const additionalQuery = `
                            SELECT pack_name, module_name, torque, angle, torque_status, date_dd, shift, module_barcode, process_status, pack_no, rework_status, bypass_operator, bypass_reason, process_name, station_name, smoke_sensor_linked_pack_no 
                            FROM taco_treceability.torque_details_EIP 
                            WHERE pack_no LIKE '%${safeQRCode}%'
                        `;
                        const additionalResult = await pool.request().query(additionalQuery);
                        totalCount += additionalResult.recordset.length;
                    }

                    console.log('TOTAL Count_EIP_data:', totalCount);
                    socket.emit('total_eip_data_count_fe', totalCount);

                } catch (err) {
                    console.error("Error during FinalQRCode fetching:", err);
                }
            });

            socket.removeAllListeners('date_selected_OK');
            socket.on('date_selected_OK', async (date) => {
                console.log("Received date from client IRRRR shift:", date);

                const final_qrcode_arr_eip = [];
                try {
                    const pool = await poolPromise;
                    const query = `
                        SELECT DISTINCT pack_no 
                        FROM taco_treceability.torque_details_EIP 
                        WHERE CONVERT(varchar(200), date_dd) < '${date}' 
                          AND pack_no != 'not_linked'
                    `;
                    const result = await pool.request().query(query);
                    result.recordset.forEach(row => final_qrcode_arr_eip.push(row.pack_no));

                    const collectedFinalQRCodes = [];
                    for (const packNo of final_qrcode_arr_eip) {
                        const safePackNo = packNo.replace(/'/g, "''");
                        const innerQuery = `
                            SELECT DISTINCT FinalQRCode 
                            FROM taco_treceability.station_status 
                            WHERE FinalQRCode LIKE '%${safePackNo}%' 
                              AND FinalQRCodePrint_status = 'OK'
                        `;
                        const innerResult = await pool.request().query(innerQuery);
                        if (innerResult.recordset.length > 0) {
                            const foundCodes = innerResult.recordset.map(r => r.FinalQRCode);
                            collectedFinalQRCodes.push(...foundCodes);
                        }
                    }

                    // ‚úÖ Insert & delete logic
                    // The NOT OK insertion logic remains unchanged
                    // ... (copy your existing logic here exactly)
                    for (const finalQRCode of collectedFinalQRCodes) {
                        const safeQRCode = finalQRCode.replace(/'/g, "''");
                        const additionalQuery = `
                            SELECT pack_name, module_name, torque, angle, torque_status, date_dd, shift, module_barcode, process_status, 
                                   pack_no, rework_status, bypass_operator, bypass_reason, process_name, station_name, smoke_sensor_linked_pack_no 
                            FROM taco_treceability.torque_details_EIP 
                            WHERE pack_no LIKE '%${safeQRCode}%'
                        `;
                        const additionalResult = await pool.request().query(additionalQuery);
                        if (additionalResult.recordset.length > 0) {
                            for (const record of additionalResult.recordset) {
                                const insertQuery = `
                                    INSERT INTO taco_treceability.torque_details_EIP_import2
                                    (pack_name, module_name, torque, angle, torque_status, date_dd, shift, module_barcode, 
                                     process_status, pack_no, rework_status, bypass_operator, bypass_reason, process_name, station_name, 
                                     smoke_sensor_linked_pack_no)
                                    VALUES
                                    ('${record.pack_name}', '${record.module_name}', '${record.torque}', '${record.angle}', 
                                     '${record.torque_status}', '${record.date_dd}', '${record.shift}', '${record.module_barcode}', 
                                     '${record.process_status}', '${record.pack_no}', '${record.rework_status}', '${record.bypass_operator}', 
                                     '${record.bypass_reason}', '${record.process_name}', '${record.station_name}', '${record.smoke_sensor_linked_pack_no}')
                                `;
                                await pool.request().query(insertQuery);
                            }
                            console.log('Data inserted into torque_details_EIP_import2 for QRCode:', finalQRCode);
                        }
                    }

                    const deleteQuery = `
                        DELETE FROM taco_treceability.torque_details_EIP 
                        WHERE pack_no IN (${collectedFinalQRCodes.map(qr => `'${qr.replace(/'/g, "''")}'`).join(', ')})
                    `;
                    await pool.request().query(deleteQuery);
                    console.log("Data deleted from torque_details_EIP");

                    socket.emit("data_inserted_and_deleted", { message: "Data has been inserted and deleted successfully" });

                } catch (err) {
                    console.error("Error during FinalQRCode fetching and insertion:", err);
                }
            });

            /////////////////////////////// NOT OK DATA
            // The NOT OK insertion logic remains unchanged
            // ... (copy your existing logic here exactly)

        });

        console.log('IRTesing code imported');
    }
};
