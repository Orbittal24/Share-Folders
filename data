import time
import redis
import pytz
import pyodbc
import requests
from datetime import datetime
from cpppo.server.enip.get_attribute import proxy_simple
from multiprocessing import Process, current_process, Event
from threading import Thread
from get_ips_from_sql import fetch_ip_list

# ------------------------------------------------------------------
# CONSTANTS
# ------------------------------------------------------------------
REAL_INDICES = [1, 4, 7, 10, 13, 16]
UINT_INDICES = [4, 10, 16, 22, 28, 34]

REDIS_HASH = 'controller_data'

SQL_CONN_STR = (
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=TGTCNWS904;'
    'DATABASE=taco_treceability_ir_config;'
    'UID=user_mis;'
    'PWD=admin'
)

API_ENDPOINT = 'https://misapp.tataautocomp.com:3241/trigger_nomenclature_fetch'

# ------------------------------------------------------------------
# UTILS
# ------------------------------------------------------------------
def get_formatted_timestamp():
    utc = datetime.utcnow()
    ist = pytz.timezone('Asia/Kolkata')
    return utc.replace(tzinfo=pytz.utc).astimezone(ist).strftime('%Y-%m-%d %H:%M:%S')

def extract_selected_values(data, indices):
    return [data[i] for i in indices if i < len(data)]

# ------------------------------------------------------------------
# API (ASYNC + DEBOUNCE)
# ------------------------------------------------------------------
_last_api_call = {}

def should_trigger_api(key, interval=1.5):
    now = time.time()
    if key not in _last_api_call or now - _last_api_call[key] > interval:
        _last_api_call[key] = now
        return True
    return False

def trigger_api(payload):
    try:
        r = requests.post(API_ENDPOINT, json=payload, timeout=5)
        if r.status_code != 200:
            print("[API ERROR]", r.status_code)
    except Exception as e:
        print("[API FAIL]", e)

def trigger_api_async(payload):
    Thread(target=trigger_api, args=(payload,), daemon=True).start()

# ------------------------------------------------------------------
# PROCESS LOOKUP
# ------------------------------------------------------------------
def find_process_record(cursor, controller_ip, gun):
    queries = [
        """
        SELECT TOP 1 Process_ID, Running_Count, Pack_ID, Angle_Array, Line
        FROM taco_treceability.Process_Register_master
        WHERE Torque_Array = ?
          AND CHARINDEX(',' + ?, ',' + Angle_Array + ',') > 0
        ORDER BY Process_ID DESC
        """,
        """
        SELECT TOP 1 Process_ID, Running_Count, Pack_ID, Angle_Array, Line
        FROM taco_treceability.TrayAssemblyBoltingCount_master
        WHERE Torque_Array = ?
          AND Angle_Array = ?
        ORDER BY Process_ID DESC
        """
    ]

    for q in queries:
        cursor.execute(q, controller_ip, str(gun))
        for row in cursor.fetchall():
            if str(gun) in str(row.Angle_Array).split(','):
                return {
                    "Process_ID": row.Process_ID,
                    "Running_Count": row.Running_Count,
                    "Pack_ID": row.Pack_ID,
                    "Line": row.Line
                }
    return None

# ------------------------------------------------------------------
# SQL + REDIS + API
# ------------------------------------------------------------------
def update_sql_redis_api(
    conn, redis_client,
    ip, gun, torque, angle, timestamp,
    last_sql_values
):
    key = f"{ip}_{gun}"
    received_data = f"{torque},{angle}"

    if last_sql_values.get(key) == received_data:
        return

    last_sql_values[key] = received_data

    cursor = conn.cursor()
    process = find_process_record(cursor, ip, gun)
    if not process:
        return

    # ------------------------------
    # ðŸ”¥ API CALL FIRST (ASYNC)
    # ------------------------------
    api_key = f"{ip}{gun}{process['Process_ID']}"
    if should_trigger_api(api_key):
        trigger_api_async({
            "station_id": process["Running_Count"],
            "controller_ip": ip,
            "pack_id": process["Pack_ID"],
            "gun": gun,
            "process_id": process["Process_ID"],
            "line_id": process["Line"],
            "Received_Data": received_data
        })

    # ------------------------------
    # SQL UPDATE
    # ------------------------------
    cursor.execute("""
        UPDATE dbo.ir_controller_configuration
        SET Received_Data = ?, Date_Time = ?
        WHERE controller_ip = ?
          AND gun = ?
          AND Process_ID = ?
          AND station_id = ?
          AND Pack_ID = ?
          AND (Received_Data <> ? OR Received_Data IS NULL)
    """, (
        received_data, timestamp, ip, gun,
        process["Process_ID"],
        process["Running_Count"],
        process["Pack_ID"],
        received_data
    ))

    if cursor.rowcount > 0:
        conn.commit()

        # ------------------------------
        # Redis UPDATE
        # ------------------------------
        redis_client.hset(
            REDIS_HASH,
            ip,
            f'{{"ip":"{ip}","guns":{{"gun_{gun}":{{"torque":{torque},"angle":{angle},"timestamp":"{timestamp}"}}}}}}'
        )

# ------------------------------------------------------------------
# ENIP READER
# ------------------------------------------------------------------
def enip_reader(ip, stop_event):
    print(f"[START] {ip}")

    conn = pyodbc.connect(SQL_CONN_STR)
    redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)

    last_sql_values = {}
    last_enip_values = {}
    retry = 5

    while not stop_event.is_set():
        try:
            with proxy_simple(ip, timeout=3) as via:
                retry = 5
                print(f"[CONNECTED] {ip}")

                while not stop_event.is_set():
                    real, uint = via.read([
                        ('@4/100/3', 'REAL'),
                        ('@4/100/3', 'UINT'),
                    ])

                    real_vals = extract_selected_values(real, REAL_INDICES)
                    uint_vals = extract_selected_values(uint, UINT_INDICES)

                    timestamp = get_formatted_timestamp()

                    for i in range(min(len(real_vals), len(uint_vals))):
                        pair = (real_vals[i], uint_vals[i])
                        if last_enip_values.get(i) != pair:
                            last_enip_values[i] = pair
                            update_sql_redis_api(
                                conn, redis_client,
                                ip, i + 1,
                                pair[0], pair[1],
                                timestamp,
                                last_sql_values
                            )

                    time.sleep(0.1)

        except Exception as e:
            print(f"[RECONNECT] {ip} {e}")
            time.sleep(retry)
            retry = min(retry * 2, 60)

    conn.close()
    print(f"[STOPPED] {ip}")

# ------------------------------------------------------------------
# MAIN
# ------------------------------------------------------------------
def main():
    processes = {}
    stop_event = Event()

    print("[INFO] Monitoring controllers...")

    try:
        while not stop_event.is_set():
            current_ips = set(fetch_ip_list())
            tracked_ips = set(processes.keys())

            for ip in current_ips - tracked_ips:
                p = Process(target=enip_reader, args=(ip, stop_event), name=f"Reader-{ip}")
                p.start()
                processes[ip] = p

            for ip in tracked_ips - current_ips:
                processes[ip].terminate()
                del processes[ip]

            for ip, p in list(processes.items()):
                if not p.is_alive():
                    np = Process(target=enip_reader, args=(ip, stop_event))
                    np.start()
                    processes[ip] = np

            time.sleep(1)

    except KeyboardInterrupt:
        print("[STOP] Shutting down...")
        stop_event.set()
        for p in processes.values():
            p.join()

    print("[OK] Clean shutdown")

if _name_ == "_main_":
    main()
