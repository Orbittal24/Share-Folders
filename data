const sql = require('mssql');
const axios = require('axios');
const stringSimilarity = require('string-similarity');

const sqlConfig1 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig2 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability_master",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig3 = {
  user: "user_mis",
  password: "admin",
  database: "master_taco_treceability_IR",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

let lastSeenSrNo = 0;
let pool1, pool2, pool3;

const startFetchLoop = async () => {
  await fetchLatestRows();
};

const init = async () => {
  try {
    pool1 = await new sql.ConnectionPool(sqlConfig1).connect();
    console.log("Connected to 10.9.4.28 taco_treceability");

    pool2 = await new sql.ConnectionPool(sqlConfig2).connect();
    console.log("Connected to 10.9.4.28 taco_treceability_master");

    pool3 = await new sql.ConnectionPool(sqlConfig3).connect();
    console.log("Connected to 10.9.4.28 master_taco_treceability_IR");

    startFetchLoop();
  } catch (err) {
    console.error("Error connecting to databases:", err);
  }
};

const normalizeProcess = (text) =>
  text.toLowerCase()
      .replace(/[^a-z0-9+\/\-()& ]/g, '')
      .replace(/\s+/g, ' ')
      .trim();

const getCommonWordsScore = (a, b) => {
  const setA = new Set(a.split(' '));
  const setB = new Set(b.split(' '));
  const common = [...setA].filter(w => setB.has(w));
  return common.length / Math.max(setA.size, setB.size);
};

const uniqueProcesses = [
  "BDU -ve to HV -ve busbar (18.4)",
  "BDU -ve to HV -ve busbar (21.3)",
  "BDU to M3 +ve busbar (18.4)",
  "BDU to M3 +ve busbar (21.3)",
  "BMS bracket installation (18.4)",
  "BMS bracket installation (21.3)",
  "BMS to BMS bracket installation (18.4)",
  "BMS to BMS bracket installation (21.3)",
  "Breather plug 1 (18.4)",
  "Breather plug 1 (21.3)",
  "C plate fixing plate installation (18.4)",
  "C plate fixing plate installation (21.3)",
  "Exposion proof valve (18.4)",
  "Exposion proof valve (21.3)",
  "HV +ve to relay busbar (18.4)",
  "HV +ve to relay busbar (21.3)",
  "HV -ve to BDU -ve busbar (18.4)",
  "HV -ve to BDU -ve busbar (21.3)",
  "L plate bracket (18.4)",
  "L plate bracket (21.3)",
  "LV to ground (18.4)",
  "LV to ground (21.3)",
  "Module fixing (18.4)",
  "Module fixing (21.3)",
  "Module plate tie rod assembly (18.4)",
  "Module plate tie rod assembly (21.3)",
  "Module side plate to L bracket (18.4)",
  "Module side plate to L bracket (21.3)",
  "Module to busbar install M1 +ve to shunt (18.4)",
  "Module to busbar install M1 +ve to shunt (21.3)",
  "Module to busbar install M1 to M2 (18.4)",
  "Module to busbar install M1 to M2 (21.3)",
  "Module to busbar install M2 +ve to HV MSD +ve (18.4)",
  "Module to busbar install M2 +ve to HV MSD +ve (21.3)",
  "Module to busbar install M3 +ve to BDU +ve (18.4)",
  "Module to busbar install M3 +ve to BDU +ve (21.3)",
  "Module to busbar install M3 -ve to HV MSD -ve (18.4)",
  "Module to busbar install M3 -ve to HV MSD -ve (21.3)",
  "MSD +ve to M2 +ve busbar (18.4)",
  "MSD +ve to M2 +ve busbar (21.3)",
  "MSD -ve to M3 -ve busbar (18.4)",
  "MSD -ve to M3 -ve busbar (21.3)",
  "Relay -ve to HV +ve and main -ve (18.4)",
  "Relay -ve to HV +ve and main -ve (21.3)",
  "Relay to shunt busbar (18.4)",
  "Relay to shunt busbar (21.3)",
  "Shunt to M1 -ve busbar (18.4)",
  "Shunt to M1 -ve busbar (21.3)",
  "Shunt to relay busbar (18.4)",
  "Shunt to relay busbar (21.3)",
  "Side bracket self tapping lower (18.4)",
  "Side bracket self tapping lower (21.3)",
  "Side bracket self tapping upper (18.4)",
  "Side bracket self tapping upper (21.3)",
  "Tray cover fitment (18.4)",
  "Tray cover fitment (21.3)",
];

const fetchLatestRows = async () => {
  try {
    const processListSQL = uniqueProcesses.map(p => `'${p.replace(/'/g, "''")}'`).join(',');

    const result = await pool1.request().query(`
      SELECT TOP(1) sr_no, pack_name, module_name, module_barcode, torque, angle,
             process_name, date_dd, pack_no, smoke_sensor_linked_pack_no, bypass_operator
      FROM taco_treceability.torque_details_EIP_mirror
      WHERE sr_no > ${lastSeenSrNo}
        AND pack_name IN ('Ejeeto 18.4','Ejeeto 21.3')
        AND process_name IN (${processListSQL})
      ORDER BY sr_no ASC
    `);

    console.log('result', result);

    for (const row of result.recordset) {
      const processedPackNo = row.pack_no === 'not_linked' ? 'not_linked' : row.pack_no.slice(-6);
      const packRes = await pool2.request().query(`
        SELECT Pack_ID FROM taco_treceability.master_pack
        WHERE Pack_Name='${row.pack_name}'
      `);
      if (!packRes.recordset.length) continue;
      const packID = packRes.recordset[0].Pack_ID;

      let scanType, scanID, moduleName, modulebarQR;
      if (!row.smoke_sensor_linked_pack_no || row.smoke_sensor_linked_pack_no.toLowerCase() === 'null') {
        const modRes = await pool2.request().query(`
          SELECT Module_Name, Module_ID FROM taco_treceability.master_module
          WHERE moduleNumber='${row.module_name}' AND Pack_ID='${packID}'
        `);

        if (!modRes.recordset.length) continue;
        scanType = 'Module';
        scanID = modRes.recordset[0].Module_ID;
        moduleName = modRes.recordset[0].Module_Name;
      } else {
        const bomRes = await pool2.request().query(`
          SELECT BOM_ID FROM taco_treceability.BOM_Master
          WHERE BOM_Name='Smoke sensor' AND Pack_ID='${packID}'
        `);
        if (!bomRes.recordset.length) continue;
        scanType = 'BOM';
        scanID = bomRes.recordset[0].BOM_ID;
      }

      if (row.module_barcode.startsWith('DJ')) {
        const qrRes = await pool1.request().query(`
          SELECT CustomerQRCode FROM taco_treceability.final_qrcode_details
          WHERE final_qrcode='${row.pack_no}'
        `);
        if (!qrRes.recordset.length) continue;
        scanType = 'Pack';
        modulebarQR = qrRes.recordset[0].CustomerQRCode;
      }

      const [pmRes, pmResPack, pmResBom] = await Promise.all([        
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_ID='${scanID}'
        `),
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_ID='${packID}' AND Scan_Name='Pack'
        `),
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_Name='BOM'
        `),
      ]);

      if (!pmRes.recordset.length) continue;
      if (scanType === 'Pack' && !pmResPack.recordset.length) continue;
      if (scanType === 'BOM' && !pmResBom.recordset.length) continue;

      let best = { score:0, processID:null, totalCount:null, scanName:null, processName:'' };
      let best1 = {...best}, best2 = {...best};

      // Module match logic
      if (scanType === 'Module') {
        const inputNorm = normalizeProcess(row.process_name);
        const modKey = moduleName.toLowerCase();

        for (const p of pmRes.recordset) {
          const raw = p.Process_Name.toLowerCase();
          const needsModuleMatch = /\bM\d+\b/i.test(raw);
          if (needsModuleMatch && !raw.includes(`m${modKey}`)) continue;

          const cand = normalizeProcess(p.Process_Name);
          let score = 0;
          if (inputNorm === cand) score = 1;
          else if (cand.startsWith(inputNorm)) score = 0.99;
          else if (cand.includes(inputNorm)) score = 0.95;
          else if (inputNorm.includes(cand)) score = 0.9;
          else {
            score = 0.7 * getCommonWordsScore(inputNorm, cand) +
                    0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);
          }

          if (score > best.score ||
              (score === best.score && p.Process_Name.length < best.processName.length)) {
            best = { score, processID: p.Process_ID, totalCount: p.Total_Count, scanName: p.Scan_Name, processName: p.Process_Name };
          }
        }
        if (!best.processID || best.score < 0.5) continue;
      }

      // Pack match logic
      else if (scanType === 'Pack') {
        const inputNorm = normalizeProcess(row.process_name);
        const inputRaw = row.process_name.toLowerCase();
        const arr = [];

        for (const p of pmResPack.recordset) {
          const raw = p.Process_Name.toLowerCase();
          const cand = normalizeProcess(p.Process_Name);

          let score=0;
          if (inputRaw === raw) score=1;
          else if (raw.startsWith(inputRaw)) score=0.99;
          else if (raw.includes(inputRaw)) score=0.95;
          else if (inputRaw.includes(raw)) score=0.9;
          else {
            score = 0.7 * getCommonWordsScore(inputNorm, cand) +
                    0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);
          }

          arr.push({ score, processID: p.Process_ID, totalCount: p.Total_Count, scanName: p.Scan_Name, processName: p.Process_Name });
        }
        arr.sort((a,b) => b.score - a.score || a.processName.length - b.processName.length);
        best1 = arr[0];
        if (!best1.processID || best1.score < 0.5) continue;
      }

      // BOM match logic
      else if (scanType === 'BOM') {
        const inputWords = row.process_name.match(/[\w()+\-\/&]+/g);
        if (!inputWords || inputWords.length === 0) continue;
      
        const matches = [];
      
        for (const p of pmResBom.recordset) {
          const processWords = p.Process_Name.match(/[\w()+\-\/&]+/g) || [];
          const allMatch = inputWords.every(word => processWords.includes(word));
          if (allMatch) {
            matches.push({
              score: 1,
              processID: p.Process_ID,
              totalCount: p.Total_Count,
              scanName: p.Scan_Name,
              processName: p.Process_Name
            });
          }
        }
      
        matches.sort((a, b) => b.score - a.score || a.processName.length - b.processName.length);
        best2 = matches[0];
        if (!best2?.processID || best2.score < 0.5) continue;
      }

      // API calls & deletions
      const handleCompletedProcess = async (putUrl, module_barcode, row) => {
        try {
          const processIdMatch = putUrl.match(/Process_ID=(\d+)/);
          const processId = processIdMatch ? processIdMatch[1] : null;

          if (!processId) {
            console.error("Process_ID not found in PUT_url:", putUrl);
          } else {
            const stationResult = await pool3
              .request()
              .query(`SELECT Station_ID FROM taco_treceability.Process_Master WHERE Process_ID = '${processId}'`);
            if (stationResult.recordset.length === 0) {
              console.error("No Station_ID found for Process_ID:", processId);
            } else {
              const stationId = stationResult.recordset[0].Station_ID;
              const stationPayload = {
                station_id: stationId,
                line_id: "1",
                customer_qrcode: module_barcode,
                station_status: "OK",
                checklist_name: "NA",
                substation_id: processId
              };
              try {
                const stationResponse = await axios.post(
                  "https://mismainapp.tataautocomp.com:3241/station_status/filter",
                  stationPayload
                );
                console.log("Station Status API Response:", JSON.stringify(stationResponse.data, null, 2));
              } catch (stationErr) {
                console.error("Error sending Station Status API:", stationErr.message);
                if (stationErr.response) console.error("Station API Error Response:", JSON.stringify(stationErr.response.data, null, 2));
              }
            }
          }
          await pool1.request().query(
            `DELETE FROM taco_treceability.torque_details_EIP_mirror WHERE sr_no = ${row.sr_no}`
          );
          console.log(`Deleted sr_no ${row.sr_no} after successful update.`);
          return startFetchLoop();
        } catch (innerErr) {
          console.error("Error in Process Completed flow:", innerErr.message);
        }
      };

      if (scanType === 'Module') {
        const api1Payload = {
          pack_id: String(packID),
          process_id: best.processID,
          time: row.date_dd,
          module_name: moduleName,
          target_count: best.totalCount,
          pack_no: processedPackNo,
          line_id: 1,
          Received_Data: `${row.torque},${row.angle}`,
          module_barcode: row.module_barcode
        };
        console.log("API1 api1Payload:", api1Payload);
        try {
          const response = await axios.post('https://mismainapp.tataautocomp.com:3241/trigger_process_data', api1Payload);
          const message = response.data?.message || '';
          const Process_Status = response.data?.Process_Status || '';
          const putUrl = response.data?.PUT_url || '';
          const module_barcode = response.data?.module_barcode || '';

          if (message === "Process register updated successfully" && Process_Status === "Pending") {
            await pool1.request().query(`DELETE FROM taco_treceability.torque_details_EIP_mirror WHERE sr_no = ${row.sr_no}`);
            console.log(`Deleted sr_no ${row.sr_no} after successful update.`);
            return startFetchLoop();
          } else if (message === "Process register updated successfully" && Process_Status === "Completed") {
            await handleCompletedProcess(putUrl, module_barcode, row);
          } else if (message === "Process already completed. No update necessary.") {
            await pool1.request().query(`
              DELETE FROM taco_treceability.torque_details_EIP_mirror
              WHERE pack_no = '${row.pack_no}'
                AND module_barcode = '${row.module_barcode}'
                AND process_name = '${row.process_name}'
                AND pack_name = '${row.pack_name}'
            `);
            console.log(`Deleted all matching rows for already completed process: pack_name=${row.pack_name}, pack_no=${row.pack_no}, barcode=${row.module_barcode}`);
            return startFetchLoop();
          }
        } catch (err) {
          console.error('API1 send error:', err.message);
          if (err.response) console.error('API1 Error Response:', JSON.stringify(err.response.data, null, 2));
        }
      }

      // Similarly, repeat Pack and BOM API calls with handleCompletedProcess logic
      // ... (keep same as Module section, just replace payload & best object)
      // Due to length, they follow the same structure with `best1` for Pack and `best2` for BOM

      if (row.sr_no > lastSeenSrNo) lastSeenSrNo = row.sr_no;
    }

    setTimeout(startFetchLoop, 3000); 
 
