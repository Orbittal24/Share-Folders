const sql = require("mssql");
const Redis = require("ioredis");

// -------------------------
// DB CONFIGS
// -------------------------
const sqlConfig1 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability",
  server: "10.9.4.28",
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig2 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability_OVC",
  server: "10.9.4.28",
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

// -------------------------
// REDIS CONFIG
// -------------------------
const redis = new Redis({
  host: "127.0.0.1",
  port: 6379,
});

// -------------------------
// MAPPING TABLES
// -------------------------
const yearMap = {
  B: 21, C: 22, D: 23, E: 24, F: 25, G: 26, H: 27, J: 28, K: 29, L: 30,
  M: 31, N: 32, P: 33, R: 34, S: 35, T: 36, V: 37, W: 38, X: 39, Y: 40,
  1: 41, 2: 42, 3: 43, 4: 44, 5: 45, 6: 46, 7: 47, 8: 48, 9: 49, A: 50
};

const monthMap = { 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12 };

const dayMap = {
  1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
  A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, G: 16, H: 17, J: 18, K: 19,
  L: 20, M: 21, N: 22, P: 23, R: 24, S: 25, T: 26, V: 27, W: 28, X: 29,
  Y: 30, 0: 31
};

const specialCodes = ["BJ", "CJ", "CR", "GD", "AG", "DR"];

// -------------------------
// HELPERS
// -------------------------
function safeString(val) {
  return val == null ? null : val.toString();
}

function safeDate(val) {
  if (!val) return null;
  try {
    const d = new Date(val);
    if (!isNaN(d.getTime())) return d.toISOString();
  } catch (e) {}
  return null;
}

// -------------------------
// PROCESS ONE RECORD
// -------------------------
async function processRecord() {

  // Create isolated SQL pools (fix for your issue)
  const srcPool = new sql.ConnectionPool(sqlConfig1);
  const dstPool = new sql.ConnectionPool(sqlConfig2);
  const src = await srcPool.connect();
  const dst = await dstPool.connect();

  try {
    // Fetch ONE record
    const fetch = await src.request().query(`
      SELECT TOP 1 *
      FROM taco_treceability.ocv_machine_data_mirror
      ORDER BY sr_no ASC
    `);

    if (fetch.recordset.length === 0) {
      console.log("No new records...");
      return;
    }

    const row = fetch.recordset[0];
    const qr = row.cell_qrcode;

    console.log("\n================ NEW RECORD ================");
    console.log("QR CODE:", qr);

    if (!qr || qr.length < 16) {
      console.error("âŒ ERROR: QR too short. Skipping.");
      return;
    }

    const code12_13 = qr.substring(12, 14);
    console.log("Extracted 12-13 Code:", code12_13);

    let dateCode = specialCodes.includes(code12_13)
      ? qr.substring(14, 17)
      : qr.substring(8, 11);

    console.log("Extracted Date Code:", dateCode);

    const yearValue = yearMap[dateCode[0]];
    const monthValue = monthMap[dateCode[1]];
    const dayValue = dayMap[dateCode[2]];

    if (!yearValue || !monthValue || !dayValue) {
      console.error("âŒ ERROR: Date mapping failed. Skipping.");
      return;
    }

    const year = 2000 + yearValue;
    const month = monthValue.toString().padStart(2, "0");
    const day = dayValue.toString().padStart(2, "0");

    const tableName = `dbo.ocv_cell_data_${year}_${month}_${day}`;
    const redisKey = `ocv_cell_data:${year}_${month}_${day}`;

    console.log("SQL Table:", tableName);
    console.log("Redis Key:", redisKey);

    // CREATE TABLE IN sqlConfig2 (now guaranteed)
    await dst.request().query(`
      IF NOT EXISTS (
        SELECT 1 FROM INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_SCHEMA='dbo' AND TABLE_NAME='ocv_cell_data_${year}_${month}_${day}'
      )
      CREATE TABLE dbo.ocv_cell_data_${year}_${month}_${day} (
          sr_no INT,
          cell_qrcode VARCHAR(100),
          voltage VARCHAR(50),
          ir VARCHAR(50),
          today_date DATETIME,
          updated_time DATETIME,
          machine_location VARCHAR(50),
          shift VARCHAR(10),
          used_on_line VARCHAR(10),
          kvalue VARCHAR(50),
          grade VARCHAR(50),
          cell_capacity VARCHAR(50),
          cell_class VARCHAR(50)
      );
    `);

    // REDIS INIT
    await redis.hset(redisKey, "initialized", "1");

    // SQL BEFORE UPSERT
    const check = await dst.request()
      .input("qr", sql.VarChar, qr)
      .query(`SELECT * FROM ${tableName} WHERE cell_qrcode = @qr`);

    const payload = {
      sr_no: row.sr_no,
      cell_qrcode: row.cell_qrcode,
      voltage: safeString(row.voltage),
      ir: safeString(row.ir),
      today_date: safeDate(row.today_date),
      updated_time: safeDate(row.updated_time),
      machine_location: row.machine_location,
      shift: row.shift,
      used_on_line: row.used_on_line,
      kvalue: safeString(row.kvalue),
      grade: row.grade,
      cell_capacity: safeString(row.cell_capacity),
      cell_class: row.cell_class
    };

    // INSERT OR UPDATE
    if (check.recordset.length === 0) {
      await dst.request()
        .input("sr_no", sql.Int, row.sr_no)
        .input("cell_qrcode", sql.VarChar, row.cell_qrcode)
        .input("voltage", sql.VarChar, payload.voltage)
        .input("ir", sql.VarChar, payload.ir)
        .input("today_date", sql.DateTime, row.today_date)
        .input("updated_time", sql.DateTime, row.updated_time)
        .input("machine_location", sql.VarChar, row.machine_location)
        .input("shift", sql.VarChar, row.shift)
        .input("used_on_line", sql.VarChar, row.used_on_line)
        .input("kvalue", sql.VarChar, payload.kvalue)
        .input("grade", sql.VarChar, row.grade)
        .input("cell_capacity", sql.VarChar, payload.cell_capacity)
        .input("cell_class", sql.VarChar, row.cell_class)
        .query(`
          INSERT INTO ${tableName}
          VALUES (@sr_no, @cell_qrcode, @voltage, @ir, @today_date, @updated_time,
                  @machine_location, @shift, @used_on_line, @kvalue, @grade,
                  @cell_capacity, @cell_class)
        `);

      console.log("âœ… SQL INSERTED");
    } else {
      await dst.request()
        .input("qr", sql.VarChar, qr)
        .input("voltage", sql.VarChar, payload.voltage)
        .input("ir", sql.VarChar, payload.ir)
        .input("today_date", sql.DateTime, row.today_date)
        .input("updated_time", sql.DateTime, row.updated_time)
        .input("machine_location", sql.VarChar, row.machine_location)
        .input("shift", sql.VarChar, row.shift)
        .input("used_on_line", sql.VarChar, row.used_on_line)
        .input("kvalue", sql.VarChar, payload.kvalue)
        .input("grade", sql.VarChar, row.grade)
        .input("cell_capacity", sql.VarChar, payload.cell_capacity)
        .input("cell_class", sql.VarChar, row.cell_class)
        .query(`
          UPDATE ${tableName}
          SET voltage=@voltage, ir=@ir, today_date=@today_date, updated_time=@updated_time,
              machine_location=@machine_location, shift=@shift, used_on_line=@used_on_line,
              kvalue=@kvalue, grade=@grade, cell_capacity=@cell_capacity, cell_class=@cell_class
          WHERE cell_qrcode = @qr
        `);

      console.log("ðŸ”„ SQL UPDATED");
    }

    // REDIS UPSERT
    await redis.hset(redisKey, qr, JSON.stringify(payload));
    console.log("ðŸ“¦ Redis update done");

    // DELETE SOURCE ROW
    await src.request()
      .input("qr", sql.VarChar, qr)
      .query(`DELETE FROM taco_treceability.ocv_machine_data_mirror WHERE cell_qrcode = @qr`);

    console.log("ðŸ—‘ï¸ SOURCE ROW DELETED");

  } finally {
    // IMPORTANT: Close connections
    srcPool.close();
    dstPool.close();
  }
}

// -------------------------
// CONTINUOUS LOOP
// -------------------------
async function start() {
  while (true) {
    try {
      await processRecord();
    } catch (err) {
      console.error("ERROR:", err);
    }
    await new Promise(res => setTimeout(res, 1000));
  }
}

start();
