# reader_process.py

import time
import redis
import pytz
import pyodbc
from datetime import datetime
from cpppo.server.enip.get_attribute import proxy_simple
from multiprocessing import Process, current_process, Event
from get_ips_from_sql import fetch_ip_list

# Constants
REAL_INDICES = [1, 4, 7, 10, 13, 16]
UINT_INDICES = [4, 10, 16, 22, 28, 34]
REDIS_HASH = 'controller_data'

SQL_CONN_STR = (
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=TGTCNWS904;'
    'DATABASE=taco_treceability_ir;'
    'UID=user_mis;'
    'PWD=admin'
)


def get_formatted_timestamp():
    utc_time = datetime.utcnow()
    ist = pytz.timezone('Asia/Kolkata')
    local_time = utc_time.replace(tzinfo=pytz.utc).astimezone(ist)
    return local_time.strftime('%Y-%m-%d %H:%M:%S')


def extract_selected_values(full_list, indices):
    return [full_list[i] for i in indices if i < len(full_list)]


def update_sql(ip, gun_number, torque, angle, timestamp):
    try:
        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()
        received_data = f"{torque},{angle}"
        cursor.execute("""
            UPDATE taco_treceability.ir_controller_configuration
            SET Received_Data = ?, Date_Time = ?
            WHERE controller_ip = ? AND gun = ?
        """, (received_data, timestamp, ip, gun_number))
        conn.commit()
        cursor.close()
        conn.close()
        print(f"[SQL] [OK] Updated IP {ip}, Gun {gun_number} → {received_data}")
    except Exception as e:
        print(f"[SQL] [ERROR] {ip} Gun {gun_number}: {e}")


def enip_reader(ip, stop_event: Event):
    print(f"[{current_process().name}] Reader started for {ip}")
    last_values = {}
    retry_delay = 5

    r = redis.Redis(host='localhost', port=6379, db=0)

    while not stop_event.is_set():
        try:
            with proxy_simple(ip, timeout=3) as via:
                print(f"[{ip}] Connected")
                retry_delay = 5  # reset on success

                while not stop_event.is_set():
                    try:
                        # ✅ Combined read (same data, fewer CIP calls)
                        real_value, uint_value = via.read([
                            ('@4/100/3', 'REAL'),
                            ('@4/100/3', 'UINT'),
                        ])

                        real_selected = extract_selected_values(real_value, REAL_INDICES)
                        uint_selected = extract_selected_values(uint_value, UINT_INDICES)
                        timestamp = get_formatted_timestamp()

                        gun_entries = []
                        redis_update_needed = False

                        for i in range(min(len(real_selected), len(uint_selected))):
                            torque = real_selected[i]
                            angle = uint_selected[i]
                            gun_id = f"gun_{i+1}"
                            current_pair = (torque, angle)

                            if last_values.get(i) != current_pair:
                                last_values[i] = current_pair
                                redis_update_needed = True
                                update_sql(ip, i + 1, torque, angle, timestamp)

                                gun_entries.append(
                                    f'"{gun_id}": {{"torque": {torque}, '
                                    f'"angle": {angle}, '
                                    f'"timestamp": "{timestamp}"}}'
                                )

                        if redis_update_needed:
                            redis_json = f'{{"ip": "{ip}", "guns": {{{", ".join(gun_entries)}}}}}'
                            r.hset(REDIS_HASH, ip, redis_json)
                            print(f"[{ip}] Redis + SQL updated")
                        else:
                            print(f"[{ip}] No gun data changed")

                        time.sleep(5)  # same logic, safer rate

                    except Exception as read_err:
                        print(f"[{ip}] Read error: {read_err}")
                        break  # reconnect

        except Exception as conn_err:
            print(f"[{ip}] Connection error: {conn_err}")
            time.sleep(retry_delay)
            retry_delay = min(retry_delay * 2, 60)

    print(f"[{ip}] Reader stopped cleanly")


def main():
    processes = {}
    stop_event = Event()

    print("[INFO] Monitoring IP list...")

    try:
        while not stop_event.is_set():
            current_ips = set(fetch_ip_list())
            tracked_ips = set(processes.keys())

            for ip in current_ips - tracked_ips:
                print(f"[START] Reader for {ip}")
                p = Process(
                    target=enip_reader,
                    args=(ip, stop_event),
                    name=f"Reader-{ip}"
                )
                p.start()
                processes[ip] = p

            for ip in tracked_ips - current_ips:
                print(f"[STOP] IP removed {ip}")
                processes[ip].join(timeout=2)
                del processes[ip]

            for ip, p in list(processes.items()):
                if not p.is_alive():
                    print(f"[RESTART] Reader died for {ip}")
                    np = Process(
                        target=enip_reader,
                        args=(ip, stop_event),
                        name=f"Reader-{ip}"
                    )
                    np.start()
                    processes[ip] = np

            time.sleep(1)

    except KeyboardInterrupt:
        print("\n[STOP] Gracefully stopping readers...")
        stop_event.set()
        for p in processes.values():
            p.join()
        print("[OK] All readers stopped cleanly")


if __name__ == "__main__":
    main()
