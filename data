# reader_process.py

import time
import redis
import pytz
import pyodbc
from datetime import datetime
from cpppo.server.enip.get_attribute import proxy_simple
from multiprocessing import Process, current_process
from get_ips_from_sql import fetch_ip_list
import requests

# ---------------- CONFIG ---------------- #

REAL_INDICES = [1, 4, 7, 10, 13, 16]
UINT_INDICES = [4, 10, 16, 22, 28, 34]
REDIS_HASH = 'controller_data'

SQL_CONN_STR = (
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=TGTCNWS904;'
    'DATABASE=taco_treceability_ir;'
    'UID=user_mis;'
    'PWD=admin'
)

API_ENDPOINT = 'https://misapp.tataautocomp.com:3241/trigger_nomenclature_fetch'

# ---------------- UTILITIES ---------------- #

def get_formatted_timestamp():
    utc_time = datetime.utcnow()
    ist = pytz.timezone('Asia/Kolkata')
    local_time = utc_time.replace(tzinfo=pytz.utc).astimezone(ist)
    return local_time.strftime('%Y-%m-%d %H:%M:%S')

def extract_selected_values(full_list, indices):
    return [full_list[i] for i in indices if i < len(full_list)]

# ---------------- PROCESS ID LOOKUP ---------------- #

def get_process_ids(cursor, ip, gun_number):
    """Returns ALL matching Process_IDs for single or multiple guns"""
    process_ids = []
    gun_str = str(gun_number)

    queries = [
        "taco_treceability.Process_Register_master",
        "taco_treceability.TrayAssemblyBoltingCount_master"
    ]

    for table in queries:
        cursor.execute(f"""
            SELECT Process_ID, Angle_Array
            FROM {table}
            WHERE Torque_Array = ?
              AND Angle_Array LIKE ?
        """, (ip, f"%{gun_str}%"))

        for pid, angle_array in cursor.fetchall():
            guns = [g.strip() for g in angle_array.split(",")]
            if gun_str in guns:
                process_ids.append(pid)

    return process_ids

# ---------------- API TRIGGER (NON-BLOCKING) ---------------- #

def trigger_api(ip, gun_number, timestamp):
    try:
        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()

        cursor.execute("""
            SELECT srno, station_id, controller_ip, pack_id, gun,
                   process_id, line_id, Received_Data
            FROM taco_treceability.ir_controller_configuration
            WHERE controller_ip = ?
              AND gun = ?
              AND Date_Time = ?
        """, (ip, gun_number, timestamp))

        rows = cursor.fetchall()
        session = requests.Session()

        for row in rows:
            payload = {
                "station_id": row.station_id,
                "controller_ip": row.controller_ip,
                "pack_id": row.pack_id,
                "gun": row.gun,
                "process_id": row.process_id,
                "line_id": row.line_id,
                "Received_Data": row.Received_Data
            }

            try:
                response = session.post(API_ENDPOINT, json=payload, timeout=5)
                if response.status_code == 200:
                    print(f"[API] Triggered for srno {row.srno}")
                else:
                    print(f"[API] Failed srno {row.srno} â†’ {response.status_code}")
            except Exception as e:
                print("[API] Error:", e)

        cursor.close()
        conn.close()

    except Exception as e:
        print("[API] DB error:", e)

# ---------------- SQL UPDATE ---------------- #

def update_sql(ip, gun_number, torque, angle, timestamp):
    try:
        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()

        process_ids = get_process_ids(cursor, ip, gun_number)

        if not process_ids:
            print(f"[SQL] No process_id for IP {ip}, Gun {gun_number}")
            return

        received_data = f"{torque},{angle}"

        for pid in process_ids:
            cursor.execute("""
                UPDATE taco_treceability.ir_controller_configuration
                SET Received_Data = ?, Date_Time = ?
                WHERE controller_ip = ?
                  AND gun = ?
                  AND process_id = ?
            """, (received_data, timestamp, ip, gun_number, pid))

            print(f"[SQL] Updated IP {ip}, Gun {gun_number}, PID {pid}")

        conn.commit()
        cursor.close()
        conn.close()

        trigger_api(ip, gun_number, timestamp)

    except Exception as e:
        print("[SQL] Error:", e)

# ---------------- ENIP READER ---------------- #

def enip_reader(ip):
    print(f"[{current_process().name}] Started for {ip}")
    last_values = {}

    while True:
        try:
            with proxy_simple(ip, timeout=3) as via:
                print(f"[{ip}] Connected")
                r = redis.Redis(host='localhost', port=6379, db=0)

                while True:
                    real_value, = via.read([('@4/100/3', 'REAL')])
                    uint_value, = via.read([('@4/100/3', 'UINT')])

                    real_selected = extract_selected_values(real_value, REAL_INDICES)
                    uint_selected = extract_selected_values(uint_value, UINT_INDICES)
                    timestamp = get_formatted_timestamp()

                    gun_entries = []
                    redis_update_needed = False

                    for i in range(min(len(real_selected), len(uint_selected))):
                        torque = real_selected[i]
                        angle = uint_selected[i]
                        current = (torque, angle)

                        if last_values.get(i) != current:
                            last_values[i] = current
                            redis_update_needed = True

                            update_sql(ip, i + 1, torque, angle, timestamp)

                            gun_entries.append(
                                f'"gun_{i+1}": {{"torque": {torque}, "angle": {angle}, "timestamp": "{timestamp}"}}'
                            )

                    if redis_update_needed:
                        redis_json = f'{{"ip": "{ip}", "guns": {{{", ".join(gun_entries)}}}}}'
                        r.hset(REDIS_HASH, ip, redis_json)
                        print(f"[{ip}] Redis + SQL updated")

                    time.sleep(2)

        except Exception as e:
            print(f"[{ip}] Connection error:", e)
            time.sleep(5)

# ---------------- MAIN ---------------- #

def main():
    processes = {}
    print("[INFO] Monitoring IP list")

    while True:
        current_ips = set(fetch_ip_list())
        tracked_ips = set(processes.keys())

        for ip in current_ips - tracked_ips:
            p = Process(target=enip_reader, args=(ip,), name=f"Reader-{ip}")
            p.start()
            processes[ip] = p

        for ip in tracked_ips - current_ips:
            processes[ip].terminate()
            processes[ip].join()
            del processes[ip]

        for ip in list(processes):
            if not processes[ip].is_alive():
                p = Process(target=enip_reader, args=(ip,), name=f"Reader-{ip}")
                p.start()
                processes[ip] = p

        time.sleep(1)

if __name__ == "__main__":
    main()
