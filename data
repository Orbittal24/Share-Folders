const sql = require('mssql');
const axios = require('axios');
const stringSimilarity = require('string-similarity');
const https = require('https');

/* -------------------- AXIOS KEEP ALIVE -------------------- */
const httpsAgent = new https.Agent({
  keepAlive: true,
  maxSockets: 5,
  maxFreeSockets: 5,
  timeout: 60000
});

const apiClient = axios.create({
  httpsAgent,
  timeout: 30000
});

const sleep = ms => new Promise(r => setTimeout(r, ms));

let apiFailCount = 0;
let isRunning = false;

/* -------------------- DB CONFIG -------------------- */
const sqlConfig1 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig2 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability_master",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig3 = {
  user: "user_mis",
  password: "admin",
  database: "master_taco_treceability_IR",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

let pool1, pool2, pool3;
let lastSeenSrNo = 0;

/* -------------------- HELPERS -------------------- */
const normalizeProcess = (text) =>
  text.toLowerCase()
    .replace(/[^a-z0-9+\/\-()& ]/g, '')
    .replace(/\s+/g, ' ')
    .trim();

const getCommonWordsScore = (a, b) => {
  const setA = new Set(a.split(' '));
  const setB = new Set(b.split(' '));
  return [...setA].filter(w => setB.has(w)).length / Math.max(setA.size, setB.size);
};

const deleteRow = async (sr_no) => {
  await pool1.request().query(
    `DELETE FROM taco_treceability.torque_details_EIP_mirror WHERE sr_no=${sr_no}`
  );
};

/* -------------------- PROCESS LIST -------------------- */
const uniqueProcesses = [
  "Breather plug",
  "Top lid (Top cover)"
];

/* -------------------- MAIN LOOP -------------------- */
const fetchLatestRows = async () => {
  if (isRunning) return;
  isRunning = true;

  try {
    const processListSQL = uniqueProcesses.map(p => `'${p.replace(/'/g, "''")}'`).join(',');

    const result = await pool1.request().query(`
      SELECT sr_no, pack_name, module_name, module_barcode, torque, angle,
             process_name, date_dd, pack_no, smoke_sensor_linked_pack_no, bypass_operator
      FROM taco_treceability.torque_details_EIP_mirror
      WHERE sr_no > ${lastSeenSrNo}
        AND pack_name = 'Bajaj 12.1'
        AND process_name IN (${processListSQL})
      ORDER BY sr_no ASC
    `);

    for (const row of result.recordset) {
      lastSeenSrNo = Math.max(lastSeenSrNo, row.sr_no);

      try {
        const processedPackNo =
          row.pack_no === 'not_linked' ? 'not_linked' : row.pack_no.slice(-6);

        /* ---------------- PACK MASTER ---------------- */
        const packRes = await pool2.request().query(`
          SELECT Pack_ID FROM taco_treceability.master_pack
          WHERE Pack_Name='${row.pack_name}'
        `);
        if (!packRes.recordset.length) {
          await deleteRow(row.sr_no);
          continue;
        }
        const packID = packRes.recordset[0].Pack_ID;

        let scanType, scanID, moduleName, modulebarQR;

        /* ---------------- MODULE / BOM DECISION ---------------- */
        if (!row.smoke_sensor_linked_pack_no || row.smoke_sensor_linked_pack_no === 'null') {
          const modRes = await pool2.request().query(`
            SELECT Module_Name, Module_ID FROM taco_treceability.master_module
            WHERE moduleNumber='${row.module_name}' AND Pack_ID='${packID}'
          `);
          if (!modRes.recordset.length) {
            await deleteRow(row.sr_no);
            continue;
          }
          scanType = 'Module';
          scanID = modRes.recordset[0].Module_ID;
          moduleName = modRes.recordset[0].Module_Name;
        } else {
          const bomRes = await pool2.request().query(`
            SELECT BOM_ID FROM taco_treceability.BOM_Master
            WHERE BOM_Name='Smoke sensor' AND Pack_ID='${packID}'
          `);
          if (!bomRes.recordset.length) {
            await deleteRow(row.sr_no);
            continue;
          }
          scanType = 'BOM';
          scanID = bomRes.recordset[0].BOM_ID;
        }

        /* ---------------- PACK QR OVERRIDE ---------------- */
        if (row.module_barcode.startsWith('DJ')) {
          const qrRes = await pool1.request().query(`
            SELECT CustomerQRCode FROM taco_treceability.final_qrcode_details
            WHERE final_qrcode='${row.pack_no}'
          `);
          if (!qrRes.recordset.length) {
            await deleteRow(row.sr_no);
            continue;
          }
          scanType = 'Pack';
          modulebarQR = qrRes.recordset[0].CustomerQRCode;
        }

        /* ---------------- PROCESS MASTER ---------------- */
        const [pmRes, pmResPack, pmResBom] = await Promise.all([
          pool3.request().query(`
            SELECT Process_Name, Process_ID, Total_Count, Scan_Name
            FROM taco_treceability.Process_Master
            WHERE Pack_ID='${packID}' AND Scan_ID='${scanID}'
          `),
          pool3.request().query(`
            SELECT Process_Name, Process_ID, Total_Count, Scan_Name
            FROM taco_treceability.Process_Master
            WHERE Pack_ID='${packID}' AND Scan_ID='${packID}' AND Scan_Name='Pack'
          `),
          pool3.request().query(`
            SELECT Process_Name, Process_ID, Total_Count, Scan_Name
            FROM taco_treceability.Process_Master
            WHERE Pack_ID='${packID}' AND Scan_Name='BOM'
          `)
        ]);

        /* ================= MODULE LOGIC ================= */
        if (scanType === 'Module') {
          const inputNorm = normalizeProcess(row.process_name);
          const modKey = moduleName.toLowerCase();
          let best = { score: 0 };

          for (const p of pmRes.recordset) {
            const raw = p.Process_Name.toLowerCase();
            const needsModuleMatch = /\bM\d+\b/i.test(raw);
            const processModules = raw.match(/\bM\d+\b/gi) || [];

            if (
              needsModuleMatch &&
              !raw.includes(modKey) &&
              !processModules.some(m => m.toLowerCase() === modKey)
            ) continue;

            const cand = normalizeProcess(p.Process_Name);
            const score =
              inputNorm === cand ? 1 :
              cand.includes(inputNorm) ? 0.95 :
              inputNorm.includes(cand) ? 0.9 :
              0.7 * getCommonWordsScore(inputNorm, cand) +
              0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);

            if (score > best.score) {
              best = { score, processID: p.Process_ID, totalCount: p.Total_Count };
            }
          }

          if (!best.processID) {
            await deleteRow(row.sr_no);
            continue;
          }

          const response = await apiClient.post(
            'https://mismainapp.tataautocomp.com:3241/trigger_process_data',
            {
              pack_id: String(packID),
              process_id: best.processID,
              time: row.date_dd,
              module_name: moduleName,
              target_count: best.totalCount,
              pack_no: processedPackNo,
              line_id: 1,
              Received_Data: `${row.torque},${row.angle}`,
              module_barcode: row.module_barcode
            }
          );

          await sleep(200);

          const { message, Process_Status, PUT_url, module_barcode } = response.data || {};

          if (message === "Process register updated successfully" && Process_Status === "Pending") {
            await deleteRow(row.sr_no);
            continue;
          }

          if (message === "Process register updated successfully" && Process_Status === "Completed") {
            const processId = PUT_url?.match(/Process_ID=(\d+)/)?.[1];
            if (processId) {
              const stationRes = await pool3.request().query(`
                SELECT Station_ID FROM taco_treceability.Process_Master WHERE Process_ID='${processId}'
              `);
              if (stationRes.recordset.length) {
                await apiClient.post(
                  "https://mismainapp.tataautocomp.com:3241/station_status/filter",
                  {
                    station_id: stationRes.recordset[0].Station_ID,
                    line_id: "1",
                    customer_qrcode: module_barcode,
                    station_status: "OK",
                    checklist_name: "NA",
                    substation_id: processId
                  }
                );
                await sleep(200);
              }
            }
            await deleteRow(row.sr_no);
            continue;
          }

          if (message === "Process already completed. No update necessary.") {
            await pool1.request().query(`
              DELETE FROM taco_treceability.torque_details_EIP_mirror
              WHERE pack_no='${row.pack_no}'
                AND module_barcode='${row.module_barcode}'
                AND process_name='${row.process_name}'
                AND pack_name='${row.pack_name}'
            `);
            continue;
          }
        }

        /* ================= PACK LOGIC ================= */
        else if (scanType === 'Pack') {
          const inputNorm = normalizeProcess(row.process_name);
          let best1 = { score: 0 };

          for (const p of pmResPack.recordset) {
            const cand = normalizeProcess(p.Process_Name);
            const score =
              inputNorm === cand ? 1 :
              0.7 * getCommonWordsScore(inputNorm, cand) +
              0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);

            if (score > best1.score) {
              best1 = { score, processID: p.Process_ID, totalCount: p.Total_Count };
            }
          }

          if (!best1.processID) {
            await deleteRow(row.sr_no);
            continue;
          }

          const response = await apiClient.post(
            'https://mismainapp.tataautocomp.com:3241/trigger_process_data',
            {
              pack_id: String(packID),
              process_id: best1.processID,
              time: row.date_dd,
              module_name: row.pack_name,
              target_count: best1.totalCount,
              pack_no: processedPackNo,
              line_id: 1,
              Received_Data: `${row.torque},${row.angle}`,
              module_barcode: modulebarQR
            }
          );

          await sleep(200);

          const { message, Process_Status, PUT_url, module_barcode } = response.data || {};

          if (message === "Process register updated successfully" && Process_Status === "Pending") {
            await deleteRow(row.sr_no);
            continue;
          }

          if (message === "Process register updated successfully" && Process_Status === "Completed") {
            const processId = PUT_url?.match(/Process_ID=(\d+)/)?.[1];
            if (processId) {
              const stationRes = await pool3.request().query(`
                SELECT Station_ID FROM taco_treceability.Process_Master WHERE Process_ID='${processId}'
              `);
              if (stationRes.recordset.length) {
                await apiClient.post(
                  "https://mismainapp.tataautocomp.com:3241/station_status/filter",
                  {
                    station_id: stationRes.recordset[0].Station_ID,
                    line_id: "1",
                    customer_qrcode: module_barcode,
                    station_status: "OK",
                    checklist_name: "NA",
                    substation_id: processId
                  }
                );
                await sleep(200);
              }
            }
            await deleteRow(row.sr_no);
            continue;
          }

          if (message === "Process already completed. No update necessary.") {
            await pool1.request().query(`
              DELETE FROM taco_treceability.torque_details_EIP_mirror
              WHERE pack_no='${row.pack_no}'
                AND module_barcode='${row.module_barcode}'
                AND process_name='${row.process_name}'
                AND pack_name='${row.pack_name}'
            `);
            continue;
          }
        }

        /* ================= BOM LOGIC ================= */
        else if (scanType === 'BOM') {
          const inputNorm = normalizeProcess(row.process_name);
          let best2 = { score: 0 };

          for (const p of pmResBom.recordset) {
            const cand = normalizeProcess(p.Process_Name);
            const score =
              0.7 * getCommonWordsScore(inputNorm, cand) +
              0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);

            if (score > best2.score) {
              best2 = { score, processID: p.Process_ID, totalCount: p.Total_Count };
            }
          }

          if (!best2.processID) {
            await deleteRow(row.sr_no);
            continue;
          }

          const apiUrl =
            processedPackNo === 'not_linked'
              ? 'trigger_tray_data'
              : 'trigger_tray_after_link_data';

          await apiClient.post(
            `https://mismainapp.tataautocomp.com:3241/${apiUrl}`,
            {
              pack_id: String(packID),
              process_id: best2.processID,
              time: row.date_dd,
              bom_id: scanID,
              Pack_Number: processedPackNo,
              target_count: best2.totalCount,
              line_id: 1,
              Received_Data: `${row.torque},${row.angle}`,
              bom_qr: `${row.module_barcode},${row.module_barcode}`
            }
          );

          await sleep(200);
          await deleteRow(row.sr_no);
        }

      } catch (rowErr) {
        console.error("Row error:", rowErr.message);
        await deleteRow(row.sr_no);
      }
    }

  } catch (err) {
    console.error("Fetch loop error:", err.message);
  } finally {
    isRunning = false;
    setTimeout(fetchLatestRows, 5000);
  }
};

/* -------------------- INIT -------------------- */
const init = async () => {
  pool1 = await new sql.ConnectionPool(sqlConfig1).connect();
  pool2 = await new sql.ConnectionPool(sqlConfig2).connect();
  pool3 = await new sql.ConnectionPool(sqlConfig3).connect();
  console.log("All DBs connected");
  fetchLatestRows();
};

init();
