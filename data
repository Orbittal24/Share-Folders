const needsModuleMatch = /\bM\d+\b/i.test(raw);

// OLD logic (fixed)
const oldLogicMatch = raw.includes(modKey);

// NEW logic (token-based, middle-safe)
const processModules = raw.match(/\bM\d+\b/gi) || [];
const newLogicMatch =
  processModules.length === 0 ||
  processModules.some(m => m.toLowerCase() === modKey);

// If process mentions modules, at least ONE logic must pass
if (needsModuleMatch && !(oldLogicMatch || newLogicMatch)) {
  continue;
}



if (scanType === 'Module') {
  const inputNorm = normalizeProcess(row.process_name);
  const modKey = moduleName.toLowerCase();

  for (const p of pmRes.recordset) {
    const raw = p.Process_Name.toLowerCase();

    const needsModuleMatch = /\bM\d+\b/i.test(raw);

    const oldLogicMatch = raw.includes(modKey);

    const processModules = raw.match(/\bM\d+\b/gi) || [];
    const newLogicMatch =
      processModules.length === 0 ||
      processModules.some(m => m.toLowerCase() === modKey);

    if (needsModuleMatch && !(oldLogicMatch || newLogicMatch)) {
      continue;
    }

    const cand = normalizeProcess(p.Process_Name);

    let score = 0;
    if (inputNorm === cand) score = 1;
    else if (cand.startsWith(inputNorm)) score = 0.99;
    else if (cand.includes(inputNorm)) score = 0.95;
    else if (inputNorm.includes(cand)) score = 0.9;
    else {
      score =
        0.7 * getCommonWordsScore(inputNorm, cand) +
        0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);
    }

    if (
      score > best.score ||
      (score === best.score &&
        p.Process_Name.length < best.processName.length)
    ) {
      best = {
        score,
        processID: p.Process_ID,
        totalCount: p.Total_Count,
        scanName: p.Scan_Name,
        processName: p.Process_Name
      };
    }
  }

  if (!best.processID || best.score < 0.5) continue;
}
