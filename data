mismainapp.tataautocomp.com:3241
const sql = require('mssql');
const axios = require('axios');
const stringSimilarity = require('stringâ€‘similarity');

const sqlConfig1 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig2 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability_master",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig3 = {
  user: "user_mis",
  password: "admin",
  database: "master_taco_treceability_IR",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

let lastSeenSrNo = 0;
let pool1, pool2, pool3;

const uniqueProcesses = [
  "IBB connector installation",
  "Module installation into tray (Front 3 module - A1 B2 A3)",
  "Module installation into tray (Rear 2 module - B6 A7)",
  "Module installation on cooling plate B4 A5",
  "A1 +ve to B2 -ve module series busbar connection",
  "B2 +ve to A3 -ve module series busbar connection",
  "A7 -ve to B6 +ve module series busbar connection",
  "B4 +ve to A5 -ve module series busbar connection",
  "A5 -ve to B6 +ve module series busbar connection",
  "A1 -ve to shunt busbar",
  "A3 +ve to B4 -ve busbar",
  "B4 -ve to A3 +ve busbar",
  "A7 +ve to BDU busbar",
  "BMS mounting and ground wire",
  "HV connector LR",
  "Coolant connector inlet LR",
  "Coolant connector outlet LR",
  "BDU mounting LR",
  "Fuse mounting LR",
  "Pyro switching mounting LR",
  "Smoke sensor LR",
  "Relay mounting LR",
  "Shunt mounting LR",
  "HV +ve to pyro switch busbar LR",
  "Pyro switch to HV +ve busbar LR",
  "HV -ve to relay busbar LR",
  "Relay to shunt +ve busbar LR",
  "Shunt -ve to module A1 busbar LR",
  "Pyro switch to fuse busbar LR",
  "Fuse busbar LR",
  "BDU to fuse busbar",
  "BDU to module A7 busbar LR",
  "Top cover assembly LR",
  "Waterproof vent valve LR"
];

const normalizeProcess = text =>
  text.toLowerCase()
      .replace(/[^a-z0-9+\/\\-()& ]/g, '')
      .replace(/\s+/g, ' ')
      .trim();

const getCommonWordsScore = (a, b) => {
  const setA = new Set(a.split(' '));
  const setB = new Set(b.split(' '));
  const common = [...setA].filter(w => setB.has(w));
  return common.length / Math.max(setA.size, setB.size);
};

async function init() {
  try {
    pool1 = await new sql.ConnectionPool(sqlConfig1).connect();
    console.log("Connected to taco_treceability DB");
    pool2 = await new sql.ConnectionPool(sqlConfig2).connect();
    console.log("Connected to taco_treceability_master DB");
    pool3 = await new sql.ConnectionPool(sqlConfig3).connect();
    console.log("Connected to master_taco_treceability_IR DB");
    
    // Start the loop
    fetchLatestRows();
  } catch (err) {
    console.error("Error connecting to DBs:", err);
    setTimeout(init, 5000);
  }
}

async function fetchLatestRows() {
  try {
    const processListSQL = uniqueProcesses
      .map(p => `'${p.replace(/'/g, "''")}'`)
      .join(',');

    const query = `
      SELECT TOP(1)
        sr_no, pack_name, module_name, module_barcode, torque, angle,
        process_name, date_dd, pack_no, smoke_sensor_linked_pack_no, bypass_operator
      FROM taco_treceability.torque_details_EIP_mirror
      WHERE sr_no > ${lastSeenSrNo}
        AND pack_name = 'NOVA Prismatic LR'
        AND process_name IN (${processListSQL})
      ORDER BY sr_no ASC
    `;
    const result = await pool1.request().query(query);

    console.log("Fetched rows count:", result.recordset.length);
    if (result.recordset.length === 0) {
      // No new rows, wait and retry
      setTimeout(fetchLatestRows, 3000);
      return;
    }

    const row = result.recordset[0];
    console.log("Processing sr_no:", row.sr_no, "process_name:", row.process_name);

    // Immediately update lastSeenSrNo to prevent re-processing same row if skipped
    if (row.sr_no > lastSeenSrNo) {
      lastSeenSrNo = row.sr_no;
    }

    // Determine pack ID
    const processedPackNo = (row.pack_no === 'not_linked') ? 'not_linked' : row.pack_no.slice(-6);
    const packRes = await pool2.request()
        .query(`SELECT Pack_ID FROM taco_treceability.master_pack WHERE Pack_Name='${row.pack_name.replace("'", "''")}'`);
    if (!packRes.recordset.length) {
      console.warn("No pack found for pack_name:", row.pack_name);
      return fetchLatestRows();
    }
    const packID = packRes.recordset[0].Pack_ID;

    // Determine scanType and scanID / moduleName
    let scanType, scanID, moduleName, modulebarQR;
    const hasSmokePack = row.smoke_sensor_linked_pack_no && row.smoke_sensor_linked_pack_no.toLowerCase() !== 'null';

    if (!hasSmokePack) {
      // Module flow
      const modRes = await pool2.request()
        .query(`SELECT Module_Name, Module_ID FROM taco_treceability.master_module
                WHERE moduleNumber='${row.module_name}' AND Pack_ID='${packID}'`);
      if (!modRes.recordset.length) {
        console.warn("No module match for module_number:", row.module_name, "packID:", packID);
        return fetchLatestRows();
      }
      scanType = 'Module';
      scanID = modRes.recordset[0].Module_ID;
      moduleName = modRes.recordset[0].Module_Name;
    } else {
      // BOM flow
      const bomRes = await pool2.request()
        .query(`SELECT BOM_ID FROM taco_treceability.BOM_Master
                WHERE BOM_Name='Smoke sensor' AND Pack_ID='${packID}'`);
      if (!bomRes.recordset.length) {
        console.warn("No BOM match for smoke sensor, packID:", packID);
        return fetchLatestRows();
      }
      scanType = 'BOM';
      scanID = bomRes.recordset[0].BOM_ID;
    }

    // For pack-level QR override
    if (row.module_barcode && row.module_barcode.startsWith('DJ')) {
      const qrRes = await pool1.request()
        .query(`SELECT CustomerQRCode FROM taco_treceability.final_qrcode_details
                WHERE final_qrcode='${row.pack_no.replace("'", "''")}'`);
      if (qrRes.recordset.length) {
        scanType = 'Pack';
        modulebarQR = qrRes.recordset[0].CustomerQRCode;
      }
    }

    console.log("scanType determined:", scanType);

    // Fetch possible process master rows
    const pmQueries = [];
    pmQueries.push(
      pool3.request().query(`
        SELECT Process_Name, Process_ID, Total_Count, Scan_Name
        FROM taco_treceability.Process_Master
        WHERE Pack_ID='${packID}' AND Scan_ID='${scanID}'
      `)
    );
    pmQueries.push(
      pool3.request().query(`
        SELECT Process_Name, Process_ID, Total_Count, Scan_Name
        FROM taco_treceability.Process_Master
        WHERE Pack_ID='${packID}' AND Scan_ID='${packID}' AND Scan_Name='Pack'
      `)
    );
    pmQueries.push(
      pool3.request().query(`
        SELECT Process_Name, Process_ID, Total_Count, Scan_Name
        FROM taco_treceability.Process_Master
        WHERE Pack_ID='${packID}' AND Scan_Name='BOM'
      `)
    );

    const [pmRes, pmResPack, pmResBom] = await Promise.all(pmQueries);

    if (!pmRes.recordset.length) {
      console.warn("No process master entries found for scan-level match");
      return fetchLatestRows();
    }

    // Matching logic
    let bestModule = null;
    let bestPack = null;
    let bestBom = null;

    const inputProcNorm = normalizeProcess(row.process_name);

    if (scanType === 'Module') {
      for (const p of pmRes.recordset) {
        const raw = p.Process_Name.toLowerCase();
        if (!raw.includes(moduleName.toLowerCase())) continue;
        const cand = normalizeProcess(p.Process_Name);
        let score = 0;
        if (inputProcNorm === cand) score = 1;
        else if (cand.startsWith(inputProcNorm)) score = 0.99;
        else if (cand.includes(inputProcNorm)) score = 0.95;
        else if (inputProcNorm.includes(cand)) score = 0.9;
        else {
          score = 0.7 * getCommonWordsScore(inputProcNorm, cand)
                + 0.3 * stringSimilarity.compareTwoStrings(inputProcNorm, cand);
        }
        if (!bestModule || score > bestModule.score ||
            (score === bestModule.score && p.Process_Name.length < bestModule.processName.length)) {
          bestModule = {
            score, processID: p.Process_ID, totalCount: p.Total_Count,
            scanName: p.Scan_Name, processName: p.Process_Name
          };
        }
      }
      if (!bestModule || bestModule.score < 0.5) {
        console.warn("Module scan: no good match for process:", row.process_name);
        return fetchLatestRows();
      }
    }
    else if (scanType === 'Pack') {
      const arr = [];
      for (const p of pmResPack.recordset) {
        const raw = p.Process_Name.toLowerCase();
        const cand = normalizeProcess(p.Process_Name);
        let score = 0;
        if (row.process_name.toLowerCase() === raw) score = 1;
        else if (raw.startsWith(row.process_name.toLowerCase())) score = 0.99;
        else if (raw.includes(row.process_name.toLowerCase())) score = 0.95;
        else if (row.process_name.toLowerCase().includes(raw)) score = 0.9;
        else {
          score = 0.7 * getCommonWordsScore(inputProcNorm, cand)
                + 0.3 * stringSimilarity.compareTwoStrings(inputProcNorm, cand);
        }
        arr.push({
          score, processID: p.Process_ID, totalCount: p.Total_Count,
          scanName: p.Scan_Name, processName: p.Process_Name
        });
      }
      if (!arr.length) {
        console.warn("Pack scan: no candidate PM entries");
        return fetchLatestRows();
      }
      arr.sort((a,b) => b.score - a.score || a.processName.length - b.processName.length);
      bestPack = arr[0];
      if (!bestPack || bestPack.score < 0.5) {
        console.warn("Pack scan: best score too low for process:", row.process_name);
        return fetchLatestRows();
      }
    }
    else if (scanType === 'BOM') {
      const inputWords = row.process_name.match(/[\w()+\-\/&]+/g);
      if (!inputWords) {
        console.warn("BOM scan: no input words extracted from process_name:", row.process_name);
        return fetchLatestRows();
      }
      const matches = [];
      for (const p of pmResBom.recordset) {
        const processWords = p.Process_Name.match(/[\w()+\-\/&]+/g) || [];
        const allMatch = inputWords.every(w => processWords.includes(w));
        if (allMatch) {
          matches.push({
            score: 1,
            processID: p.Process_ID, totalCount: p.Total_Count,
            scanName: p.Scan_Name, processName: p.Process_Name
          });
        }
      }
      if (!matches.length) {
        console.warn("BOM scan: no full-word match for:", row.process_name);
        return fetchLatestRows();
      }
      matches.sort((a,b) => b.score - a.score || a.processName.length - b.processName.length);
      bestBom = matches[0];
      if (!bestBom || bestBom.score < 0.5) {
        console.warn("BOM scan: best score too low");
        return fetchLatestRows();
      }
    }

    // Helper: send API and possibly delete row
    async function callApiAndDelete(payload, url, deleteOnSuccess = true, onCompletedExtra = null) {
      console.log("Calling API:", url, "payload:", payload);
      try {
        const resp = await axios.post(url, payload, {
          headers: { "Content-Type": "application/json" }
        });
        console.log("API response:", resp.data);
        const message = resp.data?.message || '';
        const Process_Status = resp.data?.Process_Status || '';
        const putUrl = resp.data?.PUT_url || '';
        const module_barcode = resp.data?.module_barcode || '';

        if (message.includes("updated successfully") && Process_Status === "Pending") {
          if (deleteOnSuccess) {
            await pool1.request().query(`DELETE FROM taco_treceability.torque_details_EIP_mirror WHERE sr_no = ${row.sr_no}`);
            console.log("Deleted sr_no (Pending):", row.sr_no);
          }
          return fetchLatestRows();
        }
        else if (message.includes("updated successfully") && Process_Status === "Completed") {
          // Optionally handle station status
          try {
            const processIdMatch = putUrl.match(/Process_ID=(\\d+)/);
            const processId = processIdMatch ? processIdMatch[1] : null;
            if (processId) {
              const stationResult = await pool3.request()
                .query(`SELECT Station_ID FROM taco_treceability.Process_Master WHERE Process_ID='${processId}'`);
              if (stationResult.recordset.length) {
                const stationId = stationResult.recordset[0].Station_ID;
                const stationPayload = {
                  station_id: stationId.toString(),
                  line_id: "1",
                  customer_qrcode: module_barcode,
                  station_status: "OK",
                  checklist_name: "NA",
                  substation_id: processId
                };
                console.log("Station payload:", stationPayload);
                await axios.post("https://mismainapp.tataautocomp.com:3241/station_status/filter", stationPayload, {
                  headers: { "Content-Type": "application/json" }
                });
              }
            }
          } catch (e) {
            console.error("Station status error:", e.message, e.response?.data);
          }
          if (deleteOnSuccess) {
            await pool1.request().query(`DELETE FROM taco_treceability.torque_details_EIP_mirror WHERE sr_no = ${row.sr_no}`);
            console.log("Deleted sr_no (Completed):", row.sr_no);
          }
          return fetchLatestRows();
        }
        else if (message.includes("already completed")) {
          // Delete matching records if process already done
          if (deleteOnSuccess) {
            await pool1.request()
              .query(`
                DELETE FROM taco_treceability.torque_details_EIP_mirror
                WHERE pack_no = '${row.pack_no.replace("'", "''")}'
                  AND module_barcode = '${row.module_barcode.replace("'", "''")}'
                  AND process_name = '${row.process_name.replace("'", "''")}'
                  AND pack_name = '${row.pack_name.replace("'", "''")}'
              `);
            console.log("Deleted duplicates due to already completed:", row.sr_no);
          }
          return fetchLatestRows();
        } else {
          console.warn("API did not respond as expected. message:", message, "Process_Status:", Process_Status);
        }
      } catch (err) {
        console.error("Error calling API:", err.message, err.response?.data);
      }
      // In case of error or unexpected message, proceed to next attempt after delay
      setTimeout(fetchLatestRows, 5000);
    }

    // Based on type, call appropriate API
    if (scanType === 'Module') {
      const payload = {
        pack_id: String(packID),
        process_id: bestModule.processID,
        time: row.date_dd,
        module_name: moduleName,
        target_count: bestModule.totalCount,
        pack_no: processedPackNo,
        line_id: 1,
        Received_Data: `${row.torque},${row.angle}`,
        module_barcode: row.module_barcode
      };
      await callApiAndDelete(payload, 'https://mismainapp.tataautocomp.com:3241/trigger_process_data');
    }
    else if (scanType === 'Pack') {
      const payload = {
        pack_id: String(packID),
        process_id: bestPack.processID,
        time: row.date_dd,
        module_name: row.pack_name,
        target_count: bestPack.totalCount,
        pack_no: processedPackNo,
        line_id: 1,
        Received_Data: `${row.torque},${row.angle}`,
        module_barcode: modulebarQR
      };
      await callApiAndDelete(payload, 'https://mismainapp.tataautocomp.com:3241/trigger_process_data');
    }
    else if (scanType === 'BOM') {
      // Two different endpoints depending on whether pack is linked
      const common = {
        pack_id: String(packID),
        process_id: bestBom.processID,
        time: row.date_dd,
        bom_id: scanID,
        Pack_Number: processedPackNo,
        target_count: bestBom.totalCount,
        line_id: 1,
        Received_Data: `${row.torque},${row.angle}`,
        bom_qr: (row.bypass_operator === 'na')
          ? `${row.module_barcode},${row.module_barcode}`
          : `${row.module_barcode},${row.bypass_operator}`
      };
      if (processedPackNo !== 'not_linked') {
        await callApiAndDelete(common, 'https://mismainapp.tataautocomp.com:3241/trigger_tray_after_link_data');
      } else {
        await callApiAndDelete(common, 'https://mismainapp.tataautocomp.com:3241/trigger_tray_data');
      }
    } else {
      console.error("Unknown scanType, skipping row:", scanType, row);
      return fetchLatestRows();
    }

  } catch (err) {
    console.error("Error in fetchLatestRows:", err);
    setTimeout(fetchLatestRows, 5000);
  }
}

init();
