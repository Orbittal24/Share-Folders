import time
import redis
import pytz
import pyodbc
import json
from datetime import datetime
from cpppo.server.enip.get_attribute import proxy_simple
from multiprocessing import Process, Event
from get_ips_from_sql import fetch_ip_list

# ------------------------------------------------------------------
# CONSTANTS
# ------------------------------------------------------------------
REAL_INDICES = [1, 4, 7, 10, 13, 16]
UINT_INDICES = [4, 10, 16, 22, 28, 34]

REDIS_HASH = 'controller_data'

SQL_CONN_STR = (
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=TGTCNWS904;'
    'DATABASE=taco_treceability_ir;'
    'UID=user_mis;'
    'PWD=admin'
)

# ------------------------------------------------------------------
# UTILS
# ------------------------------------------------------------------
def get_formatted_timestamp():
    utc = datetime.utcnow()
    ist = pytz.timezone('Asia/Kolkata')
    return utc.replace(tzinfo=pytz.utc).astimezone(ist).strftime('%Y-%m-%d %H:%M:%S')


def extract_selected_values(data, indices):
    return [data[i] for i in indices if i < len(data)]

# ------------------------------------------------------------------
# FIND PROCESS RECORD (UNCHANGED)
# ------------------------------------------------------------------
def find_process_record(cursor, controller_ip, gun):

    cursor.execute("""
        SELECT TOP 1
            srno,
            Process_ID,
            Time,
            Line,
            Pack_temp_number,
            Module_barcode,
            Module_name,
            Pack_ID,
            Running_Count,
            Process_Status,
            Torque_Array,
            Angle_Array,
            Target_Count
        FROM taco_treceability.Process_Register_master
        WHERE Torque_Array = ?
          AND CHARINDEX(',' + ?, ',' + Angle_Array + ',') > 0
        ORDER BY srno DESC
    """, controller_ip, str(gun))

    row = cursor.fetchone()
    if row:
        columns = [c[0] for c in cursor.description]
        result = dict(zip(columns, row))
        result["source_table"] = "Process_Register_master"
        return result

    cursor.execute("""
        SELECT TOP 1
            srno,
            Process_ID,
            Time,
            Line,
            BOM_ID,
            Running_Count,
            Pack_Number,
            Pack_ID,
            Process_Status,
            BOM_QR,
            Torque_Array,
            Angle_Array,
            Target_Count
        FROM taco_treceability.TrayAssemblyBoltingCount_master
        WHERE Torque_Array = ?
          AND Angle_Array = ?
        ORDER BY Process_ID DESC
    """, controller_ip, str(gun))

    row = cursor.fetchone()
    if row:
        columns = [c[0] for c in cursor.description]
        result = dict(zip(columns, row))
        result["source_table"] = "TrayAssemblyBoltingCount_master"
        return result

    return None

# ------------------------------------------------------------------
# PROCESS REGISTER UPDATE (UNCHANGED LOGIC)
# ------------------------------------------------------------------
def trigger_nomenclature_fetch(row, received_data):
    try:
        torque_str, angle_str = received_data.split(",")
        torque = round(float(torque_str), 2)
        angle = round(float(angle_str), 2)

        def parse_range(val):
            low, high = map(float, val.replace("Nm", "").replace("Â°", "").split("-"))
            return low, high

        torque_min, torque_max = parse_range(row["Module_name"])
        angle_min, angle_max = parse_range(row["Process_Status"])

        if not (torque_min <= torque <= torque_max and angle_min <= angle <= angle_max):
            return

        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()

        cursor.execute("""
            SELECT Running_Count, Target_Count, Process_Status,
                   Torque_Array, Angle_Array
            FROM taco_treceability.Process_Register
            WHERE Pack_ID=? AND Process_ID=? AND Module_barcode=?
        """, row["Pack_ID"], row["Process_ID"], row["Module_barcode"])

        rec = cursor.fetchone()
        if not rec:
            return

        running, target, status, t_arr, a_arr = rec
        t_arr = json.loads(t_arr or "[]")
        a_arr = json.loads(a_arr or "[]")

        if status == "Completed":
            return

        t_arr.append(torque)
        a_arr.append(angle)
        running += 1

        if running == target:
            status = "Completed"

        cursor.execute("""
            UPDATE taco_treceability.Process_Register
            SET Running_Count=?, Process_Status=?,
                Torque_Array=?, Angle_Array=?
            WHERE Pack_ID=? AND Process_ID=? AND Module_barcode=?
        """, running, status, json.dumps(t_arr), json.dumps(a_arr),
             row["Pack_ID"], row["Process_ID"], row["Module_barcode"])

        conn.commit()

    finally:
        try:
            cursor.close()
            conn.close()
        except:
            pass

# ------------------------------------------------------------------
# TRAY ASSEMBLY UPDATE (UNCHANGED LOGIC)
# ------------------------------------------------------------------
def trigger_tray_bolting_fetch(row, received_data):
    try:
        torque_str, angle_str = received_data.split(",")
        torque = round(float(torque_str), 2)
        angle = round(float(angle_str), 2)

        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()

        cursor.execute("""
            SELECT srno, Running_Count, Target_Count, Process_Status,
                   Torque_Array, Angle_Array
            FROM taco_treceability.TrayAssemblyBoltingCount
            WHERE Pack_ID=? AND Process_ID=? AND Line=? AND BOM_QR=?
        """, row["Pack_ID"], row["Process_ID"], row["Line"], row["BOM_QR"])

        tray = cursor.fetchone()
        if not tray:
            return

        srno, running, target, status, t_arr, a_arr = tray
        t_arr = json.loads(t_arr or "[]")
        a_arr = json.loads(a_arr or "[]")

        if status == "Completed":
            return

        t_arr.append(torque)
        a_arr.append(angle)
        running += 1

        if running == target:
            status = "Completed"

        cursor.execute("""
            UPDATE taco_treceability.TrayAssemblyBoltingCount
            SET Running_Count=?, Process_Status=?,
                Torque_Array=?, Angle_Array=?
            WHERE srno=?
        """, running, status, json.dumps(t_arr), json.dumps(a_arr), srno)

        conn.commit()

    finally:
        try:
            cursor.close()
            conn.close()
        except:
            pass

# ------------------------------------------------------------------
# SQL + REDIS UPDATE (FIXED, SAME FLOW)
# ------------------------------------------------------------------
def update_sql_redis_api(
    redis_client,
    ip, gun, torque, angle, timestamp,
    last_sql_values
):
    received_data = f"{torque},{angle}"

    with pyodbc.connect(SQL_CONN_STR) as conn:
        cursor = conn.cursor()
        process = find_process_record(cursor, ip, gun)
        if not process:
            return False

        trial_key = f"{process['Pack_ID']}_{process['Process_ID']}"

        if last_sql_values.get(f"{ip}_trial") != trial_key:
            last_sql_values.clear()
            last_sql_values[f"{ip}_trial"] = trial_key

        cache_key = f"{ip}_{gun}_{process['Pack_ID']}_{process['Process_ID']}"

        if last_sql_values.get(cache_key) == received_data:
            return False

        last_sql_values[cache_key] = received_data

        if process["source_table"] == "TrayAssemblyBoltingCount_master":
            trigger_tray_bolting_fetch(process, received_data)
        else:
            trigger_nomenclature_fetch(process, received_data)

        cursor.execute("""
            UPDATE taco_treceability.ir_controller_configuration
            SET Received_Data=?, Date_Time=?
            WHERE controller_ip=? AND gun=?
              AND Process_ID=? AND station_id=? AND Pack_ID=?
              AND (Received_Data<>? OR Received_Data IS NULL)
        """, received_data, timestamp, ip, gun,
             process["Process_ID"],
             process["Running_Count"],
             process["Pack_ID"],
             received_data)

        if cursor.rowcount:
            conn.commit()
            redis_client.hset(
                REDIS_HASH,
                ip,
                json.dumps({
                    "ip": ip,
                    "guns": {
                        f"gun_{gun}": {
                            "torque": torque,
                            "angle": angle,
                            "timestamp": timestamp
                        }
                    }
                })
            )

    return True

# ------------------------------------------------------------------
# ENIP READER (UNCHANGED)
# ------------------------------------------------------------------
def enip_reader(ip, stop_event):
    print(f"[START] {ip}")
    redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)

    last_sql_values = {}
    pending = {}

    while not stop_event.is_set():
        try:
            with proxy_simple(ip, timeout=3) as via:
                print(f"[CONNECTED] {ip}")

                while not stop_event.is_set():
                    real, uint = via.read([
                        ('@4/100/3', 'REAL'),
                        ('@4/100/3', 'UINT'),
                    ])

                    real_vals = extract_selected_values(real, REAL_INDICES)
                    uint_vals = extract_selected_values(uint, UINT_INDICES)
                    timestamp = get_formatted_timestamp()

                    for i in range(min(len(real_vals), len(uint_vals))):
                        pending[f"{ip}_{i+1}"] = (real_vals[i], uint_vals[i])

                    for key, (t, a) in list(pending.items()):
                        if update_sql_redis_api(
                            redis_client,
                            ip,
                            int(key.split('_')[1]),
                            t, a, timestamp,
                            last_sql_values
                        ):
                            del pending[key]

                    time.sleep(2)

        except Exception as e:
            print("[RECONNECT]", ip, e)
            time.sleep(3)

    print(f"[STOPPED] {ip}")

# ------------------------------------------------------------------
# MAIN (UNCHANGED)
# ------------------------------------------------------------------
def main():
    processes = {}
    stop_event = Event()

    print("[INFO] Monitoring controllers...")

    try:
        while True:
            ips = set(fetch_ip_list())

            for ip in ips - processes.keys():
                p = Process(target=enip_reader, args=(ip, stop_event))
                p.start()
                processes[ip] = p

            for ip in list(processes):
                if ip not in ips or not processes[ip].is_alive():
                    processes[ip].terminate()
                    del processes[ip]

            time.sleep(1)

    except KeyboardInterrupt:
        stop_event.set()
        for p in processes.values():
            p.join()

if __name__ == "__main__":
    main()
