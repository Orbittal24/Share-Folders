const sql = require('mssql');
const axios = require('axios');
const stringSimilarity = require('string-similarity');

/* ---------------- DB CONFIGS ---------------- */

const sqlConfig1 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig2 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability_master",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig3 = {
  user: "user_mis",
  password: "admin",
  database: "master_taco_treceability_IR",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

let lastSeenSrNo = 0;
let pool1, pool2, pool3;

/* ---------------- INIT ---------------- */

const init = async () => {
  try {
    pool1 = await new sql.ConnectionPool(sqlConfig1).connect();
    pool2 = await new sql.ConnectionPool(sqlConfig2).connect();
    pool3 = await new sql.ConnectionPool(sqlConfig3).connect();
    console.log("All DBs connected");
    startFetchLoop();
  } catch (err) {
    console.error("DB Connection error:", err);
  }
};

const startFetchLoop = async () => {
  await fetchLatestRows();
};

/* ---------------- HELPERS ---------------- */

const normalizeProcess = (text) =>
  text.toLowerCase()
    .replace(/[^a-z0-9+\/\-()& ]/g, '')
    .replace(/\s+/g, ' ')
    .trim();

const getCommonWordsScore = (a, b) => {
  const setA = new Set(a.split(' '));
  const setB = new Set(b.split(' '));
  const common = [...setA].filter(w => setB.has(w));
  return common.length / Math.max(setA.size, setB.size);
};

/* ðŸ”’ STRICT direction extractor (NEW) */
const extractDirection = (name) => {
  const match = name.match(/(.+?)\s+to\s+(.+?)\s+busbar/i);
  if (!match) return null;
  return {
    from: match[1].trim().toLowerCase(),
    to: match[2].trim().toLowerCase()
  };
};

/* ---------------- MAIN LOOP ---------------- */

const fetchLatestRows = async () => {
  try {
    const result = await pool1.request().query(`
      SELECT TOP(1) *
      FROM taco_treceability.torque_details_EIP_mirror
      WHERE sr_no > ${lastSeenSrNo}
        AND pack_name = 'Tamor'
      ORDER BY sr_no DESC
    `);

    for (const row of result.recordset) {

      const processedPackNo =
        row.pack_no === 'not_linked' ? 'not_linked' : row.pack_no.slice(-6);

      const packRes = await pool2.request().query(`
        SELECT Pack_ID FROM taco_treceability.master_pack
        WHERE Pack_Name='${row.pack_name}'
      `);
      if (!packRes.recordset.length) continue;
      const packID = packRes.recordset[0].Pack_ID;

      let scanType, scanID, moduleName;

      /* ---------------- SCAN TYPE ---------------- */

      if (!row.smoke_sensor_linked_pack_no || row.smoke_sensor_linked_pack_no === 'null') {
        const modRes = await pool2.request().query(`
          SELECT Module_Name, Module_ID
          FROM taco_treceability.master_module
          WHERE moduleNumber='${row.module_name}'
            AND Pack_ID='${packID}'
        `);
        if (!modRes.recordset.length) continue;
        scanType = 'Module';
        scanID = modRes.recordset[0].Module_ID;
        moduleName = modRes.recordset[0].Module_Name;
      } else {
        const bomRes = await pool2.request().query(`
          SELECT BOM_ID FROM taco_treceability.BOM_Master
          WHERE BOM_Name='Smoke sensor' AND Pack_ID='${packID}'
        `);
        if (!bomRes.recordset.length) continue;
        scanType = 'BOM';
        scanID = bomRes.recordset[0].BOM_ID;
      }

      /* ---------------- PROCESS MASTER ---------------- */

      const pmResBom = await pool3.request().query(`
        SELECT Process_Name, Process_ID, Total_Count, Scan_Name
        FROM taco_treceability.Process_Master
        WHERE Pack_ID='${packID}' AND Scan_Name='BOM'
      `);

      let best2 = null;

      /* ================= BOM MATCH (FIXED) ================= */

      if (scanType === 'BOM') {
        const inputDir = extractDirection(row.process_name);
        if (!inputDir) continue;

        const matches = [];

        for (const p of pmResBom.recordset) {
          const procDir = extractDirection(p.Process_Name);
          if (!procDir) continue;

          // ðŸ”’ STRICT DIRECTION MATCH
          if (
            procDir.from !== inputDir.from ||
            procDir.to !== inputDir.to
          ) {
            continue;
          }

          matches.push({
            score: 1,
            processID: p.Process_ID,
            totalCount: p.Total_Count,
            scanName: p.Scan_Name,
            processName: p.Process_Name
          });
        }

        matches.sort((a, b) => a.processName.length - b.processName.length);
        best2 = matches[0];

        if (!best2?.processID) continue;
      }

      /* ---------------- API CALL ---------------- */

      if (scanType === 'BOM' && processedPackNo !== 'not_linked') {
        const api2Payload = {
          pack_id: String(packID),
          process_id: best2.processID,
          time: row.date_dd,
          bom_id: scanID,
          Pack_Number: processedPackNo,
          target_count: best2.totalCount,
          line_id: 1,
          Received_Data: `${row.torque},${row.angle}`,
          bom_qr: `${row.module_barcode},${row.module_barcode}`
        };

        console.log("API2 payload:", api2Payload);

        const response = await axios.post(
          'https://mismainapp.tataautocomp.com:3241/trigger_tray_after_link_data',
          api2Payload
        );

        if (response.data?.message?.includes("successfully")) {
          await pool1.request().query(`
            DELETE FROM taco_treceability.torque_details_EIP_mirror
            WHERE sr_no=${row.sr_no}
          `);
          return startFetchLoop();
        }
      }

      lastSeenSrNo = row.sr_no;
    }

    setTimeout(startFetchLoop, 3000);

  } catch (err) {
    console.error("Processing error:", err);
    setTimeout(startFetchLoop, 5000);
  }
};

init();
