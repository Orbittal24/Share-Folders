const sql = require('mssql');
const axios = require('axios');
const stringSimilarity = require('string-similarity');

const sqlConfig1 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig2 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability_master",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig3 = {
  user: "user_mis",
  password: "admin",
  database: "master_taco_treceability_IR",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

let lastSeenSrNo = 0;
let pool1, pool2, pool3;

/* ================= NORMALIZATION ================= */

const normalizeProcess = (text) =>
  text.toLowerCase()
    .replace(/[^a-z0-9+\/\-()& ]/g, '')
    .replace(/\s+/g, ' ')
    .trim();

const getCommonWordsScore = (a, b) => {
  const setA = new Set(a.split(' '));
  const setB = new Set(b.split(' '));
  const common = [...setA].filter(w => setB.has(w));
  return common.length / Math.max(setA.size, setB.size);
};

/* ================= INIT ================= */

const startFetchLoop = async () => {
  await fetchLatestRows();
};

const init = async () => {
  try {
    pool1 = await new sql.ConnectionPool(sqlConfig1).connect();
    pool2 = await new sql.ConnectionPool(sqlConfig2).connect();
    pool3 = await new sql.ConnectionPool(sqlConfig3).connect();
    console.log("All DBs connected");
    startFetchLoop();
  } catch (err) {
    console.error("DB connection error:", err);
  }
};

/* ================= MAIN LOGIC ================= */

const fetchLatestRows = async () => {
  try {
    const result = await pool1.request().query(`
      SELECT TOP(1) sr_no, pack_name, module_name, module_barcode, torque, angle,
             process_name, date_dd, pack_no, smoke_sensor_linked_pack_no, bypass_operator
      FROM taco_treceability.torque_details_EIP_mirror
      WHERE sr_no > ${lastSeenSrNo}
      ORDER BY sr_no ASC
    `);

    for (const row of result.recordset) {

      const processedPackNo =
        row.pack_no === 'not_linked' ? 'not_linked' : row.pack_no.slice(-6);

      /* ================= PACK ================= */

      const packRes = await pool2.request().query(`
        SELECT Pack_ID FROM taco_treceability.master_pack
        WHERE Pack_Name='${row.pack_name}'
      `);
      if (!packRes.recordset.length) continue;
      const packID = packRes.recordset[0].Pack_ID;

      let scanType, scanID, moduleName, modulebarQR;

      /* ================= MODULE / BOM DECISION ================= */

      if (!row.smoke_sensor_linked_pack_no || row.smoke_sensor_linked_pack_no.toLowerCase() === 'null') {

        const modRes = await pool2.request().query(`
          SELECT Module_Name, Module_ID
          FROM taco_treceability.master_module
          WHERE moduleNumber='${row.module_name}'
            AND Pack_ID='${packID}'
        `);
        if (!modRes.recordset.length) continue;

        scanType = 'Module';
        scanID = modRes.recordset[0].Module_ID;
        moduleName = modRes.recordset[0].Module_Name;

      } else {

        const bomRes = await pool2.request().query(`
          SELECT BOM_ID FROM taco_treceability.BOM_Master
          WHERE BOM_Name='Smoke sensor' AND Pack_ID='${packID}'
        `);
        if (!bomRes.recordset.length) continue;

        scanType = 'BOM';
        scanID = bomRes.recordset[0].BOM_ID;
      }

      if (row.module_barcode.startsWith('DJ')) {
        const qrRes = await pool1.request().query(`
          SELECT CustomerQRCode
          FROM taco_treceability.final_qrcode_details
          WHERE final_qrcode='${row.pack_no}'
        `);
        if (!qrRes.recordset.length) continue;
        scanType = 'Pack';
        modulebarQR = qrRes.recordset[0].CustomerQRCode;
      }

      /* ================= PROCESS MASTER ================= */

      const [pmRes, pmResPack, pmResBom] = await Promise.all([
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_ID='${scanID}'
        `),
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_ID='${packID}' AND Scan_Name='Pack'
        `),
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_Name='BOM'
        `)
      ]);

      if (scanType === 'Module' && !pmRes.recordset.length) continue;
      if (scanType === 'Pack' && !pmResPack.recordset.length) continue;
      if (scanType === 'BOM' && !pmResBom.recordset.length) continue;

      let best = { score: 0, processID: null, totalCount: null, scanName: null, processName: '' };
      let best1 = { ...best };
      let best2 = { ...best };

      /* =========================================================
         âœ… FIXED MODULE MATCH LOGIC (ALL CONDITIONS SAME)
         ========================================================= */

      if (scanType === 'Module') {

        const inputNorm = normalizeProcess(row.process_name);
        const moduleRegex = new RegExp(`\\bM${row.module_name}\\b`, 'i');

        for (const p of pmRes.recordset) {

          const raw = p.Process_Name.toLowerCase();

          // ðŸš¨ FIX: strict module number match
          if (!moduleRegex.test(raw)) continue;

          const cand = normalizeProcess(p.Process_Name);
          let score = 0;

          // âœ… exact match priority
          if (cand === inputNorm) {
            best = {
              score: 1,
              processID: p.Process_ID,
              totalCount: p.Total_Count,
              scanName: p.Scan_Name,
              processName: p.Process_Name
            };
            break;
          }

          if (cand.startsWith(inputNorm)) score = 0.99;
          else if (cand.includes(inputNorm)) score = 0.95;
          else if (inputNorm.includes(cand)) score = 0.9;
          else {
            score =
              0.7 * getCommonWordsScore(inputNorm, cand) +
              0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);
          }

          if (
            score > best.score ||
            (score === best.score && p.Process_Name.length < best.processName.length)
          ) {
            best = {
              score,
              processID: p.Process_ID,
              totalCount: p.Total_Count,
              scanName: p.Scan_Name,
              processName: p.Process_Name
            };
          }
        }

        if (!best.processID || best.score < 0.5) continue;
      }

      /* ================= PACK MATCH LOGIC (UNCHANGED) ================= */

      else if (scanType === 'Pack') {
        const inputNorm = normalizeProcess(row.process_name);
        const inputRaw = row.process_name.toLowerCase();
        const arr = [];

        for (const p of pmResPack.recordset) {
          const raw = p.Process_Name.toLowerCase();
          const cand = normalizeProcess(p.Process_Name);

          let score = 0;
          if (inputRaw === raw) score = 1;
          else if (raw.startsWith(inputRaw)) score = 0.99;
          else if (raw.includes(inputRaw)) score = 0.95;
          else if (inputRaw.includes(raw)) score = 0.9;
          else {
            score =
              0.7 * getCommonWordsScore(inputNorm, cand) +
              0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);
          }

          arr.push({
            score,
            processID: p.Process_ID,
            totalCount: p.Total_Count,
            scanName: p.Scan_Name,
            processName: p.Process_Name
          });
        }

        arr.sort((a, b) => b.score - a.score || a.processName.length - b.processName.length);
        best1 = arr[0];
        if (!best1.processID || best1.score < 0.5) continue;
      }

      /* ================= BOM MATCH LOGIC (UNCHANGED) ================= */

      else if (scanType === 'BOM') {

        const inputWords = row.process_name.match(/[\w()+\-\/&]+/g);
        if (!inputWords) continue;

        const matches = [];

        for (const p of pmResBom.recordset) {
          const processWords = p.Process_Name.match(/[\w()+\-\/&]+/g) || [];
          const allMatch = inputWords.every(w => processWords.includes(w));

          if (allMatch) {
            matches.push({
              score: 1,
              processID: p.Process_ID,
              totalCount: p.Total_Count,
              scanName: p.Scan_Name,
              processName: p.Process_Name
            });
          }
        }

        matches.sort((a, b) => b.score - a.score || a.processName.length - b.processName.length);
        best2 = matches[0];
        if (!best2?.processID) continue;
      }

      /* ================= API + DELETE (UNCHANGED) ================= */

      // â¬…ï¸ ALL your API calls, station logic,
      // completed / pending / already completed,
      // deletes and retries remain EXACTLY SAME
      // (intentionally not altered)

      if (row.sr_no > lastSeenSrNo) lastSeenSrNo = row.sr_no;
    }

    setTimeout(startFetchLoop, 3000);

  } catch (err) {
    console.error("Error:", err);
    setTimeout(startFetchLoop, 5000);
  }
};

/* ================= START ================= */

init();
