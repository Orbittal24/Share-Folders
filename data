const sql = require('mssql');
const axios = require('axios');
const stringSimilarity = require('string-similarity');

const sqlConfigs = {
  db1: { user: "user_mis", password: "admin", database: "taco_treceability", server: '10.9.4.28', pool: { max: 10, min: 0, idleTimeoutMillis: 30000 }, options: { encrypt: true, trustServerCertificate: true }},
  db2: { user: "user_mis", password: "admin", database: "taco_treceability_master", server: '10.9.4.28', pool: { max: 10, min: 0, idleTimeoutMillis: 30000 }, options: { encrypt: true, trustServerCertificate: true }},
  db3: { user: "user_mis", password: "admin", database: "master_taco_treceability_IR", server: '10.9.4.28', pool: { max: 10, min: 0, idleTimeoutMillis: 30000 }, options: { encrypt: true, trustServerCertificate: true }},
};

let lastSeenSrNo = 0;
let pools = {};

const uniqueProcesses = [
  "L plate bracket (21.3)","Module side plate to L bracket (21.3)","Module fixing (21.3)","Module to busbar install M3 +ve to BDU +ve (21.3)",
  "Module to busbar install M3 -ve to HV MSD -ve (21.3)","Module to busbar install M2 +ve to HV MSD +ve (21.3)","Module to busbar install M1 to M2 (21.3)",
  "Module to busbar install M1 +ve to shunt (21.3)","BMS bracket installation (21.3)","BMS to BMS bracket installation (21.3)","LV to ground (21.3)",
  "Relay -ve to HV +ve and main -ve (21.3)","HV -ve to BDU -ve busbar (21.3)","HV +ve to relay busbar (21.3)","BDU to M3 +ve busbar (21.3)",
  "BDU -ve to HV -ve busbar (21.3)","Relay to shunt busbar (21.3)","Shunt to relay busbar (21.3)","Shunt to M1 -ve busbar (21.3)","MSD -ve to M3 -ve busbar (21.3)",
  "MSD +ve to M2 +ve busbar (21.3)","C plate fixing plate installation (21.3)","Side bracket self tapping lower (21.3)","Module plate tie rod assembly (21.3)",
  "Side bracket self tapping upper (21.3)","Tray cover fitment (21.3)","Breather plug 1 (21.3)","Exposion proof valve (21.3)",
  "L plate bracket (18.4)","Module side plate to L bracket (18.4)","Module fixing (18.4)","Module to busbar install M3 +ve to BDU +ve (18.4)",
  "Module to busbar install M3 -ve to HV MSD -ve (18.4)","Module to busbar install M2 +ve to HV MSD +ve (18.4)","Module to busbar install M1 to M2 (18.4)",
  "Module to busbar install M1 +ve to shunt (18.4)","BMS bracket installation (18.4)","BMS to BMS bracket installation (18.4)","LV to ground (18.4)",
  "Relay -ve to HV +ve and main -ve (18.4)","HV -ve to BDU -ve busbar (18.4)","HV +ve to relay busbar (18.4)","BDU to M3 +ve busbar (18.4)",
  "BDU -ve to HV -ve busbar (18.4)","Relay to shunt busbar (18.4)","Shunt to relay busbar (18.4)","Shunt to M1 -ve busbar (18.4)","MSD -ve to M3 -ve busbar (18.4)",
  "MSD +ve to M2 +ve busbar (18.4)","C plate fixing plate installation (18.4)","Side bracket self tapping lower (18.4)","Module plate tie rod assembly (18.4)",
  "Side bracket self tapping upper (18.4)","Tray cover fitment (18.4)","Breather plug 1 (18.4)","Exposion proof valve (18.4)"
];

const normalizeProcess = (text) => text.toLowerCase().replace(/[^a-z0-9+\/\-()& ]/g,'').replace(/\s+/g,' ').trim();
const getCommonWordsScore = (a,b) => {
  const setA = new Set(a.split(' ')), setB = new Set(b.split(' '));
  const common = [...setA].filter(w => setB.has(w));
  return common.length / Math.max(setA.size, setB.size);
};

// Initialize all DB pools
const initPools = async () => {
  try {
    pools.db1 = await new sql.ConnectionPool(sqlConfigs.db1).connect();
    pools.db2 = await new sql.ConnectionPool(sqlConfigs.db2).connect();
    pools.db3 = await new sql.ConnectionPool(sqlConfigs.db3).connect();
    console.log("Connected to all databases");
  } catch (err) { console.error("DB Connection error:", err); process.exit(1); }
};

// Fetch latest rows from torque_details_EIP_mirror
const fetchLatestRows = async () => {
  try {
    const processListSQL = uniqueProcesses.map(p => `'${p.replace(/'/g,"''")}'`).join(',');
    const result = await pools.db1.request().query(`
      SELECT TOP(1) sr_no, pack_name, module_name, module_barcode, torque, angle, process_name, date_dd, pack_no, smoke_sensor_linked_pack_no, bypass_operator
      FROM taco_treceability.torque_details_EIP_mirror
      WHERE sr_no > ${lastSeenSrNo} 
        AND pack_name IN ('Ejeeto 18.4','Ejeeto 21.3') 
        AND process_name IN (${processListSQL})
      ORDER BY sr_no ASC
    `);

    for (const row of result.recordset) {
      await processRow(row);
      if (row.sr_no > lastSeenSrNo) lastSeenSrNo = row.sr_no;
    }
    setTimeout(fetchLatestRows, 3000);
  } catch (err) {
    console.error("Error fetching rows:", err);
    setTimeout(fetchLatestRows, 5000);
  }
};

// Core logic to determine scan type and best match
const processRow = async (row) => {
  try {
    const processedPackNo = row.pack_no === 'not_linked' ? 'not_linked' : row.pack_no.slice(-6);

    const packRes = await pools.db2.request().query(`SELECT Pack_ID FROM taco_treceability.master_pack WHERE Pack_Name='${row.pack_name}'`);
    if (!packRes.recordset.length) return;
    const packID = packRes.recordset[0].Pack_ID;

    let scanType, scanID, moduleName, modulebarQR;

    if (!row.smoke_sensor_linked_pack_no || row.smoke_sensor_linked_pack_no.toLowerCase() === 'null') {
      const modRes = await pools.db2.request().query(`SELECT Module_Name, Module_ID FROM taco_treceability.master_module WHERE moduleNumber='${row.module_name}' AND Pack_ID='${packID}'`);
      if (!modRes.recordset.length) return;
      scanType = 'Module';
      scanID = modRes.recordset[0].Module_ID;
      moduleName = modRes.recordset[0].Module_Name;
    } else {
      const bomRes = await pools.db2.request().query(`SELECT BOM_ID FROM taco_treceability.BOM_Master WHERE BOM_Name='Smoke sensor' AND Pack_ID='${packID}'`);
      if (!bomRes.recordset.length) return;
      scanType = 'BOM';
      scanID = bomRes.recordset[0].BOM_ID;
    }

    if (row.module_barcode.startsWith('DJ')) {
      const qrRes = await pools.db1.request().query(`SELECT CustomerQRCode FROM taco_treceability.final_qrcode_details WHERE final_qrcode='${row.pack_no}'`);
      if (!qrRes.recordset.length) return;
      scanType = 'Pack';
      modulebarQR = qrRes.recordset[0].CustomerQRCode;
    }

    // Fetch process master records
    const [pmRes, pmResPack, pmResBOM] = await Promise.all([
      pools.db3.request().query(`SELECT Process_Name, Process_ID, Total_Count, Scan_Name FROM taco_treceability.Process_Master WHERE Pack_ID='${packID}' AND Scan_ID='${scanID}'`),
      pools.db3.request().query(`SELECT Process_Name, Process_ID, Total_Count, Scan_Name FROM taco_treceability.Process_Master WHERE Pack_ID='${packID}' AND Scan_ID='${packID}' AND Scan_Name='Pack'`),
      pools.db3.request().query(`SELECT Process_Name, Process_ID, Total_Count, Scan_Name FROM taco_treceability.Process_Master WHERE Pack_ID='${packID}' AND Scan_Name='BOM'`)
    ]);

    let bestMatch;
    if (scanType === 'Module') bestMatch = getBestModuleMatch(row.process_name, moduleName, pmRes.recordset);
    else if (scanType === 'Pack') bestMatch = getBestPackMatch(row.process_name, pmResPack.recordset);
    else if (scanType === 'BOM') bestMatch = getBestBOMMatch(row.process_name, pmResBOM.recordset);

    if (!bestMatch?.processID || bestMatch.score < 0.5) return;

    await triggerAPICall(scanType, row, bestMatch, packID, processedPackNo, moduleName, modulebarQR, scanID);
  } catch (err) {
    console.error("Error processing row:", err);
  }
};

// Match helpers
const getBestModuleMatch = (input, moduleName, processes) => {
  let best = { score: 0 };
  const inputNorm = normalizeProcess(input);
  const modKey = moduleName.toLowerCase();

  for (const p of processes) {
    const raw = p.Process_Name.toLowerCase();
    const needsModuleMatch = /\bM\d+\b/i.test(raw);
    if (needsModuleMatch && !raw.includes(`m${modKey}`)) continue;

    const cand = normalizeProcess(p.Process_Name);
    let score = inputNorm === cand ? 1
      : cand.startsWith(inputNorm) ? 0.99
      : cand.includes(inputNorm) ? 0.95
      : inputNorm.includes(cand) ? 0.9
      : 0.7 * getCommonWordsScore(inputNorm, cand) + 0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);

    if (score > best.score || (score === best.score && p.Process_Name.length < (best.processName||'').length)) {
      best = { score, processID: p.Process_ID, totalCount: p.Total_Count, scanName: p.Scan_Name, processName: p.Process_Name };
    }
  }
  return best;
};

const getBestPackMatch = (input, processes) => {
  const inputNorm = normalizeProcess(input);
  const inputRaw = input.toLowerCase();
  const matches = processes.map(p => {
    const raw = p.Process_Name.toLowerCase();
    const cand = normalizeProcess(p.Process_Name);
    let score = inputRaw === raw ? 1
      : raw.startsWith(inputRaw) ? 0.99
      : raw.includes(inputRaw) ? 0.95
      : inputRaw.includes(raw) ? 0.9
      : 0.7 * getCommonWordsScore(inputNorm, cand) + 0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);
    return { score, processID: p.Process_ID, totalCount: p.Total_Count, scanName: p.Scan_Name, processName: p.Process_Name };
  });
  matches.sort((a,b) => b.score - a.score || a.processName.length - b.processName.length);
  return matches[0];
};

const getBestBOMMatch = (input, processes) => {
  const inputWords = input.match(/[\w()+\-\/&]+/g);
  if (!inputWords?.length) return null;
  const matches = processes
    .map(p => {
      const processWords = p.Process_Name.match(/[\w()+\-\/&]+/g) || [];
      const allMatch = inputWords.every(w => processWords.includes(w));
      return allMatch ? { score: 1, processID: p.Process_ID, totalCount: p.Total_Count, scanName: p.Scan_Name, processName: p.Process_Name } : null;
    })
    .filter(Boolean);
  matches.sort((a,b) => b.score - a.score || a.processName.length - b.processName.length);
  return matches[0];
};

// Trigger API based on scanType
const triggerAPICall = async (scanType, row, best, packID, processedPackNo, moduleName, modulebarQR, scanID) => {
  try {
    if (scanType === 'Module') {
      await sendModuleAPI(row, best, packID, processedPackNo, moduleName);
    } else if (scanType === 'Pack') {
      await sendPackAPI(row, best, packID, processedPackNo, modulebarQR);
    } else if (scanType === 'BOM') {
      await sendBOMAPI(row, best, packID, processedPackNo, scanID);
    }
  } catch (err) {
    console.error("Error in API call:", err);
  }
};

// Initialization
(async () => {
  await initPools();
  fetchLatestRows();
})();
