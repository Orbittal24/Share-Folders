# reader_process.py

import time
import redis
import pytz
import pyodbc
from datetime import datetime
from cpppo.server.enip.get_attribute import proxy_simple
from multiprocessing import Process, current_process, Event
from get_ips_from_sql import fetch_ip_list

# ------------------------------------------------------------------
# CONSTANTS
# ------------------------------------------------------------------
REAL_INDICES = [1, 4, 7, 10, 13, 16]
UINT_INDICES = [4, 10, 16, 22, 28, 34]
REDIS_HASH = 'controller_data'

SQL_CONN_STR = (
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=TGTCNWS904;'
    'DATABASE=taco_treceability_ir;'
    'UID=user_mis;'
    'PWD=admin'
)

# ------------------------------------------------------------------
# UTILS
# ------------------------------------------------------------------
def get_formatted_timestamp():
    utc_time = datetime.utcnow()
    ist = pytz.timezone('Asia/Kolkata')
    local_time = utc_time.replace(tzinfo=pytz.utc).astimezone(ist)
    return local_time.strftime('%Y-%m-%d %H:%M:%S')


def extract_selected_values(full_list, indices):
    return [full_list[i] for i in indices if i < len(full_list)]

# ------------------------------------------------------------------
# ðŸ” PROCESS LOOKUP (STRICT â€“ RETURNS ONLY ONE RECORD)
# ------------------------------------------------------------------
def find_process_record(conn, controller_ip, gun):
    cursor = conn.cursor()

    queries = [
        """
        SELECT TOP 1 Process_ID, Running_Count, Pack_ID, Angle_Array
        FROM taco_treceability.Process_Register_master
        WHERE Torque_Array = ?
        ORDER BY Process_ID DESC
        """,
        """
        SELECT TOP 1 Process_ID, Running_Count, Pack_ID, Angle_Array
        FROM taco_treceability.TrayAssemblyBoltingCount_master
        WHERE Torque_Array = ?
        ORDER BY Process_ID DESC
        """
    ]

    for query in queries:
        cursor.execute(query, controller_ip)
        rows = cursor.fetchall()

        for row in rows:
            angles = [a.strip() for a in str(row.Angle_Array).split(',')]
            if str(gun) in angles:
                cursor.close()
                return {
                    "Process_ID": row.Process_ID,
                    "Running_Count": row.Running_Count,
                    "Pack_ID": row.Pack_ID
                }

    cursor.close()
    return None

# ------------------------------------------------------------------
# ðŸ§¾ SQL UPDATE (ONE ROW ONLY)
# ------------------------------------------------------------------
def update_sql_with_process(ip, gun, torque, angle, timestamp):
    try:
        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()

        process = find_process_record(conn, ip, gun)

        if not process:
            print(f"[SQL] [SKIP] No process mapping for IP {ip}, Gun {gun}")
            conn.close()
            return False

        received_data = f"{torque},{angle}"

        cursor.execute("""
            UPDATE taco_treceability.ir_controller_configuration
            SET Received_Data = ?, Date_Time = ?
            WHERE controller_ip = ?
              AND gun = ?
              AND Process_ID = ?
              AND Running_Count = ?
              AND Pack_ID = ?
        """, (
            received_data,
            timestamp,
            ip,
            gun,
            process["Process_ID"],
            process["Running_Count"],
            process["Pack_ID"]
        ))

        conn.commit()
        cursor.close()
        conn.close()

        print(f"[SQL] [OK] Updated IP {ip}, Gun {gun} â†’ {received_data}")
        return True

    except Exception as e:
        print(f"[SQL] [ERROR] {ip} Gun {gun}: {e}")
        return False

# ------------------------------------------------------------------
# ðŸ“¡ ENIP READER PROCESS
# ------------------------------------------------------------------
def enip_reader(ip, stop_event):
    print(f"[{current_process().name}] Reader started for {ip}")
    last_values = {}
    retry_delay = 5

    r = redis.Redis(host='localhost', port=6379, db=0)

    while not stop_event.is_set():
        try:
            with proxy_simple(ip, timeout=3) as via:
                print(f"[{ip}] Connected")
                retry_delay = 5

                while not stop_event.is_set():
                    try:
                        real_value, uint_value = via.read([
                            ('@4/100/3', 'REAL'),
                            ('@4/100/3', 'UINT'),
                        ])

                        real_selected = extract_selected_values(real_value, REAL_INDICES)
                        uint_selected = extract_selected_values(uint_value, UINT_INDICES)
                        timestamp = get_formatted_timestamp()

                        gun_entries = []
                        redis_update_needed = False

                        for i in range(min(len(real_selected), len(uint_selected))):
                            torque = real_selected[i]
                            angle = uint_selected[i]
                            gun_no = i + 1
                            gun_id = f"gun_{gun_no}"
                            current_pair = (torque, angle)

                            if last_values.get(i) != current_pair:
                                last_values[i] = current_pair

                                sql_updated = update_sql_with_process(
                                    ip,
                                    gun_no,
                                    torque,
                                    angle,
                                    timestamp
                                )

                                if sql_updated:
                                    redis_update_needed = True
                                    gun_entries.append(
                                        f'"{gun_id}": {{"torque": {torque}, '
                                        f'"angle": {angle}, '
                                        f'"timestamp": "{timestamp}"}}'
                                    )

                        if redis_update_needed:
                            redis_json = f'{{"ip": "{ip}", "guns": {{{", ".join(gun_entries)}}}}}'
                            r.hset(REDIS_HASH, ip, redis_json)
                            print(f"[{ip}] Redis + SQL updated")
                        else:
                            print(f"[{ip}] No gun data changed")

                        time.sleep(5)

                    except Exception as read_err:
                        print(f"[{ip}] Read error: {read_err}")
                        break

        except Exception as conn_err:
            print(f"[{ip}] Connection error: {conn_err}")
            time.sleep(retry_delay)
            retry_delay = min(retry_delay * 2, 60)

    print(f"[{ip}] Reader stopped cleanly")

# ------------------------------------------------------------------
# ðŸš€ MAIN
# ------------------------------------------------------------------
def main():
    processes = {}
    stop_event = Event()

    print("[INFO] Monitoring IP list...")

    try:
        while not stop_event.is_set():
            current_ips = set(fetch_ip_list())
            tracked_ips = set(processes.keys())

            for ip in current_ips - tracked_ips:
                print(f"[START] Reader for {ip}")
                p = Process(
                    target=enip_reader,
                    args=(ip, stop_event),
                    name=f"Reader-{ip}"
                )
                p.start()
                processes[ip] = p

            for ip in tracked_ips - current_ips:
                print(f"[STOP] IP removed {ip}")
                processes[ip].join(timeout=2)
                del processes[ip]

            for ip, p in list(processes.items()):
                if not p.is_alive():
                    print(f"[RESTART] Reader died for {ip}")
                    np = Process(
                        target=enip_reader,
                        args=(ip, stop_event),
                        name=f"Reader-{ip}"
                    )
                    np.start()
                    processes[ip] = np

            time.sleep(1)

    except KeyboardInterrupt:
        print("\n[STOP] Gracefully stopping readers...")
        stop_event.set()
        for p in processes.values():
            p.join()
        print("[OK] All readers stopped cleanly")


if __name__ == "__main__":
    main()
