const sql = require('mssql');
const axios = require('axios');
const stringSimilarity = require('string-similarity');

const sqlConfig1 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig2 = {
  user: "user_mis",
  password: "admin",
  database: "taco_treceability_master",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

const sqlConfig3 = {
  user: "user_mis",
  password: "admin",
  database: "master_taco_treceability_IR",
  server: '10.9.4.28',
  pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
  options: { encrypt: true, trustServerCertificate: true }
};

let lastSeenSrNo = 0;
let pool1, pool2, pool3;

const init = async () => {
  try {
    pool1 = await new sql.ConnectionPool(sqlConfig1).connect();
    console.log("Connected to 10.9.4.28 taco_treceability");

    pool2 = await new sql.ConnectionPool(sqlConfig2).connect();
    console.log("Connected to 10.9.4.28 taco_treceability_master");

    pool3 = await new sql.ConnectionPool(sqlConfig3).connect();
    console.log("Connected to 10.9.4.28 master_taco_treceability_IR");

    startFetchLoop();
  } catch (err) {
    console.error("Error connecting to databases:", err);
  }
};

// Normalize text for process matching
const normalizeProcess = (text) =>
  text.toLowerCase()
      .replace(/[^a-z0-9+\/\-()& ]/g, '')
      .replace(/\s+/g, ' ')
      .trim();

// Common words similarity
const getCommonWordsScore = (a, b) => {
  const setA = new Set(a.split(' '));
  const setB = new Set(b.split(' '));
  const common = [...setA].filter(w => setB.has(w));
  return common.length / Math.max(setA.size, setB.size);
};

// List of all unique processes
const uniqueProcesses = [
  "BDU -ve to HV -ve busbar (18.4)", "BDU -ve to HV -ve busbar (21.3)",
  "BDU to M3 +ve busbar (18.4)", "BDU to M3 +ve busbar (21.3)",
  "BMS bracket installation (18.4)", "BMS bracket installation (21.3)",
  "BMS to BMS bracket installation (18.4)", "BMS to BMS bracket installation (21.3)",
  "Breather plug 1 (18.4)", "Breather plug 1 (21.3)",
  "C plate fixing plate installation (18.4)", "C plate fixing plate installation (21.3)",
  "Exposion proof valve (18.4)", "Exposion proof valve (21.3)",
  "HV +ve to relay busbar (18.4)", "HV +ve to relay busbar (21.3)",
  "HV -ve to BDU -ve busbar (18.4)", "HV -ve to BDU -ve busbar (21.3)",
  "L plate bracket (18.4)", "L plate bracket (21.3)",
  "LV to ground (18.4)", "LV to ground (21.3)",
  "Module fixing (18.4)", "Module fixing (21.3)",
  "Module plate tie rod assembly (18.4)", "Module plate tie rod assembly (21.3)",
  "Module side plate to L bracket (18.4)", "Module side plate to L bracket (21.3)",
  "Module to busbar install M1 +ve to shunt (18.4)", "Module to busbar install M1 +ve to shunt (21.3)",
  "Module to busbar install M1 to M2 (18.4)", "Module to busbar install M1 to M2 (21.3)",
  "Module to busbar install M2 +ve to HV MSD +ve (18.4)", "Module to busbar install M2 +ve to HV MSD +ve (21.3)",
  "Module to busbar install M3 +ve to BDU +ve (18.4)", "Module to busbar install M3 +ve to BDU +ve (21.3)",
  "Module to busbar install M3 -ve to HV MSD -ve (18.4)", "Module to busbar install M3 -ve to HV MSD -ve (21.3)",
  "MSD +ve to M2 +ve busbar (18.4)", "MSD +ve to M2 +ve busbar (21.3)",
  "MSD -ve to M3 -ve busbar (18.4)", "MSD -ve to M3 -ve busbar (21.3)",
  "Relay -ve to HV +ve and main -ve (18.4)", "Relay -ve to HV +ve and main -ve (21.3)",
  "Relay to shunt busbar (18.4)", "Relay to shunt busbar (21.3)",
  "Shunt to M1 -ve busbar (18.4)", "Shunt to M1 -ve busbar (21.3)",
  "Shunt to relay busbar (18.4)", "Shunt to relay busbar (21.3)",
  "Side bracket self tapping lower (18.4)", "Side bracket self tapping lower (21.3)",
  "Side bracket self tapping upper (18.4)", "Side bracket self tapping upper (21.3)",
  "Tray cover fitment (18.4)", "Tray cover fitment (21.3)",
];

// ----- Fetch loop -----
const startFetchLoop = async () => {
  try {
    const processListSQL = uniqueProcesses.map(p => `'${p.replace(/'/g, "''")}'`).join(',');

    // Fetch multiple rows
    const result = await pool1.request().query(`
      SELECT TOP(10) sr_no, pack_name, module_name, module_barcode, torque, angle,
             process_name, date_dd, pack_no, smoke_sensor_linked_pack_no, bypass_operator
      FROM taco_treceability.torque_details_EIP_mirror
      WHERE sr_no > ${lastSeenSrNo}
        AND pack_name IN ('Ejeeto 18.4','Ejeeto 21.3')
        AND process_name IN (${processListSQL})
      ORDER BY sr_no ASC
    `);

    if (!result.recordset.length) {
      return setTimeout(startFetchLoop, 3000);
    }

    for (const row of result.recordset) {
      if (row.sr_no > lastSeenSrNo) lastSeenSrNo = row.sr_no; // Update immediately

      const processedPackNo = row.pack_no === 'not_linked' ? 'not_linked' : row.pack_no.slice(-6);

      // Fetch Pack_ID
      const packRes = await pool2.request().query(`
        SELECT Pack_ID FROM taco_treceability.master_pack
        WHERE Pack_Name='${row.pack_name}'
      `);
      if (!packRes.recordset.length) continue;
      const packID = packRes.recordset[0].Pack_ID;

      let scanType, scanID, moduleName, modulebarQR;

      // Determine scanType
      if (!row.smoke_sensor_linked_pack_no || row.smoke_sensor_linked_pack_no.toLowerCase() === 'null') {
        const modRes = await pool2.request().query(`
          SELECT Module_Name, Module_ID FROM taco_treceability.master_module
          WHERE moduleNumber='${row.module_name}' AND Pack_ID='${packID}'
        `);
        if (!modRes.recordset.length) continue;
        scanType = 'Module';
        scanID = modRes.recordset[0].Module_ID;
        moduleName = modRes.recordset[0].Module_Name;
      } else if (row.module_barcode.startsWith('DJ')) {
        scanType = 'Pack';
        const qrRes = await pool1.request().query(`
          SELECT CustomerQRCode FROM taco_treceability.final_qrcode_details
          WHERE final_qrcode='${row.pack_no}'
        `);
        if (!qrRes.recordset.length) continue;
        modulebarQR = qrRes.recordset[0].CustomerQRCode;
        scanID = packID;
      } else {
        scanType = 'BOM';
        const bomRes = await pool2.request().query(`
          SELECT BOM_ID FROM taco_treceability.BOM_Master
          WHERE BOM_Name='Smoke sensor' AND Pack_ID='${packID}'
        `);
        if (!bomRes.recordset.length) continue;
        scanID = bomRes.recordset[0].BOM_ID;
      }

      // Fetch process master records
      const [pmRes, pmResPack, pmResBom] = await Promise.all([
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_ID='${scanID}'
        `),
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_ID='${packID}' AND Scan_Name='Pack'
        `),
        pool3.request().query(`
          SELECT Process_Name, Process_ID, Total_Count, Scan_Name
          FROM taco_treceability.Process_Master
          WHERE Pack_ID='${packID}' AND Scan_Name='BOM'
        `),
      ]);

      if (!pmRes.recordset.length) continue;
      if (scanType === 'Pack' && !pmResPack.recordset.length) continue;
      if (scanType === 'BOM' && !pmResBom.recordset.length) continue;

      let best = { score:0, processID:null, totalCount:null, scanName:null, processName:'' };
      let best1 = {...best}, best2 = {...best};

      // ----- Module match -----
      if (scanType === 'Module') {
        const inputNorm = normalizeProcess(row.process_name);
        const modKey = moduleName.toLowerCase();

        for (const p of pmRes.recordset) {
          const raw = p.Process_Name.toLowerCase();
          const needsModuleMatch = /\bM\d+\b/i.test(raw);
          if (needsModuleMatch && !raw.includes(`m${modKey}`)) continue;

          const cand = normalizeProcess(p.Process_Name);
          let score = 0;
          if (inputNorm === cand) score = 1;
          else if (cand.startsWith(inputNorm)) score = 0.99;
          else if (cand.includes(inputNorm)) score = 0.95;
          else if (inputNorm.includes(cand)) score = 0.9;
          else score = 0.7 * getCommonWordsScore(inputNorm, cand) +
                      0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);

          if (score > best.score || (score === best.score && p.Process_Name.length < best.processName.length)) {
            best = { score, processID: p.Process_ID, totalCount: p.Total_Count, scanName: p.Scan_Name, processName: p.Process_Name };
          }
        }
        if (!best.processID || best.score < 0.5) continue;
      }

      // ----- Pack match -----
      else if (scanType === 'Pack') {
        const inputNorm = normalizeProcess(row.process_name);
        const inputRaw = row.process_name.toLowerCase();
        const arr = [];

        for (const p of pmResPack.recordset) {
          const raw = p.Process_Name.toLowerCase();
          const cand = normalizeProcess(p.Process_Name);
          let score = 0;
          if (inputRaw === raw) score = 1;
          else if (raw.startsWith(inputRaw)) score = 0.99;
          else if (raw.includes(inputRaw)) score = 0.95;
          else if (inputRaw.includes(raw)) score = 0.9;
          else score = 0.7 * getCommonWordsScore(inputNorm, cand) +
                      0.3 * stringSimilarity.compareTwoStrings(inputNorm, cand);

          arr.push({ score, processID: p.Process_ID, totalCount: p.Total_Count, scanName: p.Scan_Name, processName: p.Process_Name });
        }
        arr.sort((a,b) => b.score - a.score || a.processName.length - b.processName.length);
        best1 = arr[0];
        if (!best1.processID || best1.score < 0.5) continue;
      }

      // ----- BOM match -----
      else if (scanType === 'BOM') {
        const inputWords = row.process_name.match(/[\w()+\-\/&]+/g);
        if (!inputWords || inputWords.length === 0) continue;

        const matches = [];
        for (const p of pmResBom.recordset) {
          const processWords = p.Process_Name.match(/[\w()+\-\/&]+/g) || [];
          const allMatch = inputWords.every(word => processWords.includes(word));
          if (allMatch) matches.push({
            score: 1,
            processID: p.Process_ID,
            totalCount: p.Total_Count,
            scanName: p.Scan_Name,
            processName: p.Process_Name
          });
        }
        matches.sort((a, b) => b.score - a.score || a.processName.length - b.processName.length);
        best2 = matches[0];
        if (!best2?.processID || best2.score < 0.5) continue;
      }

      // ----- API calls -----
      try {
        await sendApiCall(row, scanType, processedPackNo, packID, moduleName, modulebarQR, best, best1, best2, scanID);
      } catch (err) {
        console.error("Error in API call for sr_no", row.sr_no, err.message);
      }
    }

    setTimeout(startFetchLoop, 3000);
  } catch (err) {
    console.error("Error fetching or processing rows:", err);
    setTimeout(startFetchLoop, 5000);
  }
};

// ----- Send API and delete row -----
async function sendApiCall(row, scanType, processedPackNo, packID, moduleName, modulebarQR, best, best1, best2, scanID) {
  if (scanType === 'Module') {
    const api1Payload = {
      pack_id: String(packID),
      process_id: best.processID,
      time: row.date_dd,
      module_name: moduleName,
      target_count: best.totalCount,
      pack_no: processedPackNo,
      line_id: 1,
      Received_Data: `${row.torque},${row.angle}`,
      module_barcode: row.module_barcode
    };
    console.log("API1 Payload:", api1Payload);
    const response = await axios.post('https://mismainapp.tataautocomp.com:3241/trigger_process_data', api1Payload);
    await handleApiResponse(response.data, row, module_barcode=row.module_barcode, scanType);
  }
  else if (scanType === 'Pack') {
    const api1Payload = {
      pack_id: String(packID),
      process_id: best1.processID,
      time: row.date_dd,
      module_name: row.pack_name,
      target_count: best1.totalCount,
      pack_no: processedPackNo,
      line_id: 1,
      Received_Data: `${row.torque},${row.angle}`,
      module_barcode: modulebarQR
    };
    console.log("API1 Payload:", api1Payload);
    const response = await axios.post('https://mismainapp.tataautocomp.com:3241/trigger_process_data', api1Payload);
    await handleApiResponse(response.data, row, module_barcode=modulebarQR, scanType);
  }
  else if (scanType === 'BOM') {
    const apiPayload = {
      pack_id: String(packID),
      process_id: best2.processID,
      time: row.date_dd,
      bom_id: scanID,
      Pack_Number: processedPackNo !== 'not_linked' ? processedPackNo : undefined,
      target_count: best2.totalCount,
      line_id: 1,
      Received_Data: `${row.torque},${row.angle}`,
      bom_qr: row.bypass_operator === 'na'
        ? `${row.module_barcode},${row.module_barcode}`
        : `${row.module_barcode},${row.bypass_operator}`
    };
    const url = processedPackNo !== 'not_linked'
      ? 'https://mismainapp.tataautocomp.com:3241/trigger_tray_after_link_data'
      : 'https://mismainapp.tataautocomp.com:3241/trigger_tray_data';
    console.log("BOM API Payload:", apiPayload);
    const response = await axios.post(url, apiPayload);
    const message = response.data?.message || '';
    if (message.includes('updated successfully') || message.includes('already completed')) {
      await pool1.request().query(`DELETE FROM taco_treceability.torque_details_EIP_mirror WHERE sr_no = ${row.sr_no}`);
      console.log(`Deleted sr_no ${row.sr_no} after BOM API update.`);
    }
  }
}

// ----- Handle response for Module/Pack -----
async function handleApiResponse(data, row, module_barcode, scanType) {
  const message = data?.message || '';
  const Process_Status = data?.Process_Status || '';
  const putUrl = data?.PUT_url || '';

  if (message === "Process register updated successfully" && Process_Status === "Pending") {
    await pool1.request().query(`DELETE FROM taco_treceability.torque_details_EIP_mirror WHERE sr_no = ${row.sr_no}`);
    console.log(`Deleted sr_no ${row.sr_no} after successful update.`);
  }
  console.log(`API ${scanType} response for sr_no ${row.sr_no}:`, message, Process_Status, putUrl);
}

init();
