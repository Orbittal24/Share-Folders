import time
import redis
import pytz
import pyodbc
import json
from datetime import datetime
from cpppo.server.enip.get_attribute import proxy_simple
from multiprocessing import Process, Event
from get_ips_from_sql import fetch_ip_list

# ------------------------------------------------------------------
# CONSTANTS
# ------------------------------------------------------------------
REAL_INDICES = [1, 4, 7, 10, 13, 16]
UINT_INDICES = [4, 10, 16, 22, 28, 34]

REDIS_HASH = 'controller_data'

SQL_CONN_STR = (
    'DRIVER={ODBC Driver 17 for SQL Server};'
    'SERVER=TGTCNWS904;'
    'DATABASE=taco_treceability_ir;'
    'UID=user_mis;'
    'PWD=admin'
)

PROCESS_CACHE_TTL = 2  # seconds

# ------------------------------------------------------------------
# UTILS
# ------------------------------------------------------------------
def get_formatted_timestamp():
    utc = datetime.utcnow()
    ist = pytz.timezone('Asia/Kolkata')
    return utc.replace(tzinfo=pytz.utc).astimezone(ist).strftime('%Y-%m-%d %H:%M:%S')


def extract_selected_values(data, indices):
    return [data[i] for i in indices if i < len(data)]

# ------------------------------------------------------------------
# SQL HELPERS (UNCHANGED LOGIC)
# ------------------------------------------------------------------
def find_process_register_table_for_record(cursor, process_time, pack_id, process_id, module_barcode):
    process_date_str = process_time.date().strftime("%d-%m-%y")
    prefix = f"Process_Register_{process_date_str}_"

    cursor.execute("""
        SELECT TABLE_NAME
        FROM INFORMATION_SCHEMA.TABLES
        WHERE TABLE_SCHEMA = 'taco_treceability'
          AND TABLE_NAME LIKE ?
        ORDER BY TABLE_NAME DESC
    """, (prefix + '%',))

    for (table_name,) in cursor.fetchall():
        cursor.execute(f"""
            SELECT 1 FROM taco_treceability.[{table_name}]
            WHERE Pack_ID=? AND Process_ID=? AND Module_barcode=?
        """, pack_id, process_id, module_barcode)

        if cursor.fetchone():
            return table_name
    return None


def find_process_record(cursor, controller_ip, gun):
    cursor.execute("""
        SELECT TOP 1 *
        FROM taco_treceability.Process_Register_master
        WHERE Torque_Array=? AND CHARINDEX(','+?, ','+Angle_Array+',')>0
        ORDER BY srno DESC
    """, controller_ip, str(gun))

    row = cursor.fetchone()
    if row:
        data = dict(zip([c[0] for c in cursor.description], row))
        data["source_table"] = "Process_Register_master"
        return data

    cursor.execute("""
        SELECT TOP 1 *
        FROM taco_treceability.TrayAssemblyBoltingCount_master
        WHERE Torque_Array=? AND Angle_Array=?
        ORDER BY Process_ID DESC
    """, controller_ip, str(gun))

    row = cursor.fetchone()
    if row:
        data = dict(zip([c[0] for c in cursor.description], row))
        data["source_table"] = "TrayAssemblyBoltingCount_master"
        return data

    return None

# ------------------------------------------------------------------
# CORE PROCESSING (UNCHANGED)
# ------------------------------------------------------------------
def trigger_nomenclature_fetch(row, received_data):
    try:
        torque, angle = map(float, received_data.split(","))
        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()

        table_name = find_process_register_table_for_record(
            cursor, row["Time"], row["Pack_ID"],
            row["Process_ID"], row["Module_barcode"]
        )

        if not table_name:
            return

        cursor.execute(f"""
            SELECT Running_Count, Target_Count, Process_Status,
                   Torque_Array, Angle_Array
            FROM taco_treceability.[{table_name}]
            WHERE Pack_ID=? AND Process_ID=? AND Module_barcode=?
        """, row["Pack_ID"], row["Process_ID"], row["Module_barcode"])

        running, target, status, t_arr, a_arr = cursor.fetchone()

        if status == "Completed":
            return

        t_arr = json.loads(t_arr or "[]")
        a_arr = json.loads(a_arr or "[]")

        t_arr.append(torque)
        a_arr.append(angle)
        running += 1

        if running == target:
            status = "Completed"

        cursor.execute(f"""
            UPDATE taco_treceability.[{table_name}]
            SET Running_Count=?, Process_Status=?,
                Torque_Array=?, Angle_Array=?
            WHERE Pack_ID=? AND Process_ID=? AND Module_barcode=?
        """, running, status, json.dumps(t_arr), json.dumps(a_arr),
             row["Pack_ID"], row["Process_ID"], row["Module_barcode"])

        conn.commit()
    finally:
        conn.close()


def trigger_tray_bolting_fetch(row, received_data):
    try:
        torque, angle = map(float, received_data.split(","))
        conn = pyodbc.connect(SQL_CONN_STR)
        cursor = conn.cursor()

        cursor.execute("""
            SELECT srno, Running_Count, Target_Count, Process_Status,
                   Torque_Array, Angle_Array
            FROM taco_treceability.TrayAssemblyBoltingCount
            WHERE Pack_ID=? AND Process_ID=? AND Line=? AND BOM_QR=?
        """, row["Pack_ID"], row["Process_ID"], row["Line"], row["BOM_QR"])

        rec = cursor.fetchone()
        if not rec:
            return

        srno, running, target, status, t_arr, a_arr = rec
        if status == "Completed":
            return

        t_arr = json.loads(t_arr or "[]")
        a_arr = json.loads(a_arr or "[]")

        t_arr.append(torque)
        a_arr.append(angle)
        running += 1

        if running == target:
            status = "Completed"

        cursor.execute("""
            UPDATE taco_treceability.TrayAssemblyBoltingCount
            SET Running_Count=?, Process_Status=?,
                Torque_Array=?, Angle_Array=?
            WHERE srno=?
        """, running, status, json.dumps(t_arr), json.dumps(a_arr), srno)

        conn.commit()
    finally:
        conn.close()

# ------------------------------------------------------------------
# SQL + REDIS UPDATE (OPTIMIZED)
# ------------------------------------------------------------------
def update_sql_redis_api(conn, cursor, redis_client,
                          ip, gun, torque, angle, timestamp,
                          last_sql_values, process_cache):

    key = f"{ip}_{gun}"
    received_data = f"{torque},{angle}"

    # ðŸ”‡ Noise filter
    if key in last_sql_values:
        lt, la = map(float, last_sql_values[key].split(","))
        if abs(lt - torque) < 0.05 and abs(la - angle) < 0.5:
            return False

    last_sql_values[key] = received_data

    now = time.time()
    cache = process_cache.get(key)
    if cache and now - cache["ts"] < PROCESS_CACHE_TTL:
        process = cache["data"]
    else:
        process = find_process_record(cursor, ip, gun)
        process_cache[key] = {"data": process, "ts": now}

    if not process:
        return False

    if process["source_table"] == "TrayAssemblyBoltingCount_master":
        trigger_tray_bolting_fetch(process, received_data)
    else:
        trigger_nomenclature_fetch(process, received_data)

    cursor.execute("""
        UPDATE taco_treceability.ir_controller_configuration
        SET Received_Data=?, Date_Time=?
        WHERE controller_ip=? AND gun=? AND Process_ID=? AND station_id=? AND Pack_ID=?
    """, received_data, timestamp, ip, gun,
         process["Process_ID"], process["Running_Count"], process["Pack_ID"])

    if cursor.rowcount:
        conn.commit()

    return True

# ------------------------------------------------------------------
# ENIP READER
# ------------------------------------------------------------------
def enip_reader(ip, stop_event):
    conn = pyodbc.connect(SQL_CONN_STR)
    cursor = conn.cursor()
    redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)

    last_sql_values = {}
    process_cache = {}

    while not stop_event.is_set():
        try:
            with proxy_simple(ip, timeout=3) as via:
                while not stop_event.is_set():
                    real, uint = via.read([
                        ('@4/100/3', 'REAL'),
                        ('@4/100/3', 'UINT'),
                    ])

                    real_vals = extract_selected_values(real, REAL_INDICES)
                    uint_vals = extract_selected_values(uint, UINT_INDICES)
                    timestamp = get_formatted_timestamp()

                    for i in range(min(len(real_vals), len(uint_vals))):
                        update_sql_redis_api(
                            conn, cursor, redis_client,
                            ip, i + 1,
                            real_vals[i], uint_vals[i],
                            timestamp, last_sql_values, process_cache
                        )

                    time.sleep(0.3)  # ðŸ”¥ CPU FIX
        except Exception:
            time.sleep(3)

    conn.close()

# ------------------------------------------------------------------
# MAIN
# ------------------------------------------------------------------
def main():
    processes = {}
    stop_event = Event()

    try:
        while True:
            ips = set(fetch_ip_list())
            for ip in ips - processes.keys():
                p = Process(target=enip_reader, args=(ip, stop_event))
                p.start()
                processes[ip] = p

            for ip in list(processes):
                if ip not in ips:
                    processes[ip].terminate()
                    del processes[ip]

            time.sleep(1)
    except KeyboardInterrupt:
        stop_event.set()
        for p in processes.values():
            p.join()

if __name__ == "__main__":
    main()
