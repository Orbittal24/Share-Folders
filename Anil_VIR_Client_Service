01TMB06S100027F9W0102030
// const express = require('express');
// const cors = require('cors');
// // const { SerialPort } = require('serialport');
// const { ReadlineParser } = require('@serialport/parser-readline');
// const fs = require('fs');
// const axios = require('axios'); // Add axios for making HTTP requests
// const SerialPort = require('serialport');

// // Setup logging
// const logStream = fs.createWriteStream('server.log', { flags: 'a' });
// console.log = function(...args) {
//   logStream.write(new Date().toISOString() + ' - ' + args.join(' ') + '\n');
//   process.stdout.write(args.join(' ') + '\n');
// };

// // Simulate serial port with random data generation
// class VirtualHiokiPort {
//   constructor() {
//     this.parser = new ReadlineParser({ delimiter: '\n' });
//     this.interval = null;
//     // Define the acceptable ranges
//     this.voltageRange = { min: 3.14, max: 5.82 };
//     this.irRange = { min: 0.7, max: 2.5 };
//     // Set out-of-range probability to 0 to ensure all values are in range
//     this.outOfRangeProbability = 0;
//   }

//   pipe(parser) {
//     return this.parser;
//   }

//   write(command) {
//     console.log('Command sent:', command.toString().trim());
    
//     return new Promise((resolve) => {
//       setTimeout(() => {
//         let response = '';
//         if (command.includes('*IDN?')) {
//           response = 'HIOKI,FT6381,123456,1.00\n';
//         } 
//         else if (command.includes(':MEASure:RESistance?')) {
//           // Generate resistance always in range
//           const resistance = (this.irRange.min + 
//                             Math.random() * (this.irRange.max - this.irRange.min))
//                             .toFixed(3);
//           response = `${resistance} OHM\n`;
//         }
//         else if (command.includes(':FETch?')) {
//           // Generate voltage and resistance always in range
//           const voltage = (this.voltageRange.min + 
//                          Math.random() * (this.voltageRange.max - this.voltageRange.min))
//                          .toFixed(2);
//           const resistance = (this.irRange.min + 
//                             Math.random() * (this.irRange.max - this.irRange.min))
//                             .toFixed(3);
          
//           response = `VOLT:${voltage}V,IR:${resistance}MΩ\n`;
//         }
//         else if (command.includes(':MEMory:STATe')) {
//           response = 'MEMORY STATE: ON\n';
//         }

//         if (response) {
//           this.parser.emit('data', response);
//         }
//         resolve(response);
//       }, 100);
//     });
//   }

//   on(event, callback) {
//     if (event === 'error') {
//       setInterval(() => {
//         if (Math.random() < 0.01) {
//           callback(new Error('Simulated serial port error'));
//         }
//       }, 10000);
//     }
//   }
// }

// // Create Express app
// const app = express();
// app.use(cors());
// app.use(express.json());

// app.use(cors({
//   origin: '*',
//   methods: ['GET', 'POST', 'OPTIONS']
// }));

// // Use virtual port
// const port = new VirtualHiokiPort();
// const parser = port.pipe(new ReadlineParser({ delimiter: '\n' }));

// let latestData = {
//   voltage: '0.00',
//   resistance: '0.00',
//   timestamp: new Date().toISOString(),   
//   Line_no:1
// };

// // Parse incoming data
// parser.on('data', (data) => {
//   console.log('Received Data:', data.trim());
  
//   // Parse the data from the format "VOLT:12.34V,IR:56.78MΩ"
//   if (data.includes('VOLT:') && data.includes('IR:')) {
//     const voltageMatch = data.match(/VOLT:([\d.]+)V/);
//     const irMatch = data.match(/IR:([\d.]+)MΩ/);

//     if (voltageMatch && irMatch) {
//       latestData = {
//         voltage: voltageMatch[1],
//         resistance: irMatch[1],
//         timestamp: new Date().toISOString(),
//         Line_no:1
//       };

//        sendToFastAPI(latestData);
//     }
//   }
// });

// // API Endpoints
// app.get('/api/measurements/latest', (req, res) => {
//   res.json(latestData);
// });

 
// // Function to send data to FastAPI
// async function sendToFastAPI(data) {
//   try {
//     const response = await fetch('http://192.168.0.172:9999/api/measurements', {
//       method: 'POST',
//       headers: { 'Content-Type': 'application/json' },
//       body: JSON.stringify({
//         voltage: data.voltage,
//         resistance: data.resistance,
//         timestamp: new Date().toISOString(),
//         Line_no: data.Line_no
//       }),
//     });
//     const result = await response.json();
//     console.log('Data sent to FastAPI:', result);
//   } catch (error) {
//     console.error('Error sending to FastAPI:', error);
//   }
// }

// app.post('/api/commands', async (req, res) => {
//   const { command } = req.body;
//   if (!command) {
//     return res.status(400).json({ error: 'Command is required' });
//   }

//   try {
//     const response = await port.write(command + '\n');
//     res.json({ success: true, response });
//   } catch (error) {
//     res.status(500).json({ error: error.message });
//   }
// });

// // Initial commands
// (async () => {
//   await port.write("*IDN?\n");
//   await port.write(":MEASure:RESistance?\n");
//   await port.write(":MEMory:STATe ON\n");

//   // Regular measurements
//   setInterval(() => {
//     port.write(":FETch?\n");
//   }, 1000);
// })();

// // Start server
// const PORT = 9123;
// app.listen(PORT, '0.0.0.0', () => {
//   console.log(`API server running on http://192.168.0.172:${PORT}`);
// });

// // Keep process alive
// process.stdin.resume();
// process.on('SIGINT', () => {
//   console.log('Shutting down server...');
//   server.close(() => process.exit());
// });


const express = require('express');
const cors = require('cors');
const { ReadlineParser } = require('@serialport/parser-readline');
const fs = require('fs');
const SerialPort = require('serialport');

// Set static Line_no to 1
const line_no = 1;
console.log(`Starting server with static Line_no: ${line_no}`);

// Setup logging
const logStream = fs.createWriteStream('server.log', { flags: 'a' });
console.log = function(...args) {
  logStream.write(new Date().toISOString() + ' - ' + args.join(' ') + '\n');
  process.stdout.write(args.join(' ') + '\n');
};

// Simulate serial port with random data generation
class VirtualHiokiPort {
  constructor() {
    this.parser = new ReadlineParser({ delimiter: '\n' });
    this.interval = null;
    // Define the acceptable ranges
    this.voltageRange = { min: 3.14, max: 5.82 };
    this.irRange = { min: 0.7, max: 2.5 };
    // Set out-of-range probability to 0 to ensure all values are in range
    this.outOfRangeProbability = 0;
  }

  pipe(parser) {
    return this.parser;
  }

  write(command) {
    console.log('Command sent:', command.toString().trim());
    
    return new Promise((resolve) => {
      setTimeout(() => {
        let response = '';
        if (command.includes('*IDN?')) {
          response = 'HIOKI,FT6381,123456,1.00\n';
        } 
        else if (command.includes(':MEASure:RESistance?')) {
          // Generate resistance always in range
          const resistance = (this.irRange.min + 
                            Math.random() * (this.irRange.max - this.irRange.min))
                            .toFixed(3);
          response = `${resistance} OHM\n`;
        }
        else if (command.includes(':FETch?')) {
          // Generate voltage and resistance always in range
          const voltage = (this.voltageRange.min + 
                         Math.random() * (this.voltageRange.max - this.voltageRange.min))
                         .toFixed(2);
          const resistance = (this.irRange.min + 
                            Math.random() * (this.irRange.max - this.irRange.min))
                            .toFixed(3);
          
          response = `VOLT:${voltage}V,IR:${resistance}MΩ\n`;
        }
        else if (command.includes(':MEMory:STATe')) {
          response = 'MEMORY STATE: ON\n';
        }

        if (response) {
          this.parser.emit('data', response);
        }
        resolve(response);
      }, 1000);
    });
  }

  on(event, callback) {
    if (event === 'error') {
      setInterval(() => {
        if (Math.random() < 0.01) {
          callback(new Error('Simulated serial port error'));
        }
      }, 1000);
    }
  }
}

// Create Express app
const app = express();
app.use(cors());
app.use(express.json());

app.use(cors({
  origin: '*',
  methods: ['GET', 'POST', 'OPTIONS']
}));

// Use virtual port
const port = new VirtualHiokiPort();
const parser = port.pipe(new ReadlineParser({ delimiter: '\n' }));

let latestData = {
  voltage: '0.00',
  resistance: '0.00',
  timestamp: new Date().toISOString(),   
  line_no: line_no // Use the static line_no
};

// Parse incoming data
parser.on('data', (data) => {
  console.log('Received Data:', data.trim());
  
  // Parse the data from the format "VOLT:12.34V,IR:56.78MΩ"
  if (data.includes('VOLT:') && data.includes('IR:')) {
    const voltageMatch = data.match(/VOLT:([\d.]+)V/);
    const irMatch = data.match(/IR:([\d.]+)MΩ/);

    if (voltageMatch && irMatch) {
      latestData = {
        voltage: voltageMatch[1],
        resistance: irMatch[1],
        timestamp: new Date().toISOString(),
        line_no: line_no // Use the static line_no
      };
      sendToFastAPI(latestData);
     
    }
  }
});

// API Endpoints
app.get('/api/measurements/latest', (req, res) => {
  res.json(latestData);
});

// Function to send data to FastAPI
async function sendToFastAPI(data) {
 
  try {
    const response = await fetch('http://192.168.0.172:9999/api/measurements', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        voltage: data.voltage,
        resistance: data.resistance,
        timestamp: data.timestamp,
        line_no: data.line_no // Static line_no of 1
      }),
    });
    const result = await response.json();
    console.log('Data sent to FastAPI:', result);
  } catch (error) {
    console.error('Error sending to FastAPI:', error);
  }
}

app.post('/api/commands', async (req, res) => {
  const { command } = req.body;
  if (!command) {
    return res.status(400).json({ error: 'Command is required' });
  }

  try {
    const response = await port.write(command + '\n');
    res.json({ success: true, response });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Initial commands
(async () => {
  await port.write("*IDN?\n");
  await port.write(":MEASure:RESistance?\n");
  await port.write(":MEMory:STATe ON\n");

  // Regular measurements
  setInterval(() => {
    port.write(":FETch?\n");
  }, 1000);
})();

// Start server
const PORT = 9123;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`API server running on http://192.168.0.172:${PORT}`);
});

// Keep process alive
process.stdin.resume();
process.on('SIGINT', () => {
  console.log('Shutting down server...');
  process.exit();
});


-----------------------------------test.js-----------------------------------------------

/**************************************
 * SERIAL PORT CONFIGURATION SERVER
 * Manages ONLY COM port via Excel
 * Other settings are hardcoded
 * Full console logging maintained
 **************************************/

const express = require('express');
const cors = require('cors');
const { SerialPort } = require('serialport');
const { ReadlineParser } = require('@serialport/parser-readline');
const XLSX = require('xlsx');
const path = require('path');

// Initialize Express app
const app = express();
app.use(cors());
app.use(express.json());

console.log('[SYSTEM] Express application initialized');
console.log('[SYSTEM] CORS and JSON middleware enabled');

// Path to Excel configuration file
const excelPath = path.join(__dirname, 'config', 'com_port_config.xlsx');
console.log(`[CONFIG] Configuration file path: ${excelPath}`);

/**
 * Reads ONLY COM port from Excel file
 * @returns {string} COM port name (e.g. 'COM1')
 */
function readCOMPort() {
  try {
    console.log('[CONFIG] Attempting to read COM port from Excel file...');
    const workbook = XLSX.readFile(excelPath);
    console.log('[CONFIG] Excel workbook loaded successfully');
    
    const worksheet = workbook.Sheets[workbook.SheetNames[0]];
    console.log('[CONFIG] Using worksheet:', workbook.SheetNames[0]);
    
    const config = XLSX.utils.sheet_to_json(worksheet)[0];
    console.log('[CONFIG] Extracted configuration:', config);
    
   // const comPort = config.Value || 'COM3';

   const Line_ID = config.Line

   console.log("Line Id =",Line_ID);

 const comPort = 'COM3';
    console.log(`[CONFIG] Determined COM port: ${comPort}`);
    
    return comPort;
  } catch (error) {
    console.error('[CONFIG] Error reading COM port configuration:', error.message);
    console.warn('[CONFIG] Falling back to default COM port: COM3');
    return 'COM3';
  }
}

// Global variables for serial communication
let port;          // Serial port instance
let parser;        // Data parser
let latestData = { // Stores the most recent measurements
  voltage: '0.00',
  resistance: '0.00',
  timestamp: new Date().toISOString()
};
let lastWasDefault = true;
console.log('[SYSTEM] Global variables initialized');

/**
 * Initializes or reinitializes the serial port connection
 */
function initializeSerialPort() {
  console.log('[SERIAL] Starting serial port initialization');
  
  const comPort = readCOMPort();
  console.log(`[SERIAL] Using COM port: ${comPort}`);
  
  const serialConfig = {
    path: comPort,
    baudRate: 9600,       // Fixed baud rate
    dataBits: 8,          // Fixed data bits
    parity: 'none',       // Fixed parity
    stopBits: 1           // Fixed stop bits
  };
  
  console.log('[SERIAL] Full serial configuration:', serialConfig);
  
  // Close existing port if it exists
  if (port) {
    console.log('[SERIAL] Existing port found, closing...');
    port.close();
    console.log('[SERIAL] Previous port closed');
  }

  // Create new serial port instance
  console.log('[SERIAL] Creating new SerialPort instance');
  port = new SerialPort(serialConfig);
  
  // Initialize parser
  console.log('[SERIAL] Initializing line parser');
  parser = port.pipe(new ReadlineParser({ delimiter: '\n' }));

  // Event handlers
  port.on('open', () => {
    console.log(`[SERIAL] Successfully opened port ${comPort}`);
    console.log('[SERIAL] Establishing communication with device...');
    sendInitialCommands();
  });

  port.on('error', (err) => {
    console.error('[SERIAL ERROR] Port error:', err.message);
  });

  parser.on('data', (data) => {
    console.log('[DATA RAW] Received:', data.trim());
    processSerialData(data);
  });
}

/**
 * Sends initial commands to the device
 */
function sendInitialCommands() {
  console.log('[COMMANDS] Beginning initial command sequence');
  
  // Device identification query
  console.log('[COMMAND] Sending identification query: *IDN?');
  port.write("*IDN?\n");
  
  // Initial resistance measurement
  console.log('[COMMAND] Sending resistance measurement request: :MEASure:RESistance?');
  port.write(":MEASure:RESistance?\n");
  
  // Enable memory state
  console.log('[COMMAND] Enabling memory state: :MEMory:STATe ON');
  port.write(":MEMory:STATe ON\n");
  
  // Set up periodic data fetching
  console.log('[COMMAND] Setting up periodic data fetching (1 second interval)');
  setInterval(() => {
    console.log('[COMMAND PERIODIC] Requesting data: :FETch?');
    port.write(":FETch?\n");
  }, 1000);
}

/**
 * Processes incoming serial data
 */
// function processSerialData(data) {
//   console.log('[DATA PROCESS] Starting data processing');
//   const cleanData = data.trim();
//   console.log('[DATA PROCESS] Cleaned data:', cleanData);
  
//   if (cleanData.includes('VOLT:') && cleanData.includes('IR:')) {
//     console.log('[DATA PROCESS] Found voltage and resistance data');
    
//     const voltageMatch = cleanData.match(/VOLT:([\d.]+)V/);
//     const irMatch = cleanData.match(/IR:([\d.]+)MΩ/);

//     if (voltageMatch && irMatch) {
//       console.log('[DATA PROCESS] Successfully extracted measurements');
//       latestData = {
//         voltage: voltageMatch[1],
//         resistance: irMatch[1],
//         timestamp: new Date().toISOString()
//       };
//       console.log('[DATA PROCESS] Updated measurements:', latestData);
//       sendToFastAPI(latestData);
//     } else {
//       console.warn('[DATA PROCESS] Failed to parse measurements from data');
//     }
//   } else {
//     console.log('[DATA PROCESS] Data does not contain measurements, likely command response');
//   }
// }

function processSerialData(data) {
  console.log('[DATA PROCESS] Starting data processing');
  const cleanData = data.trim();
  console.log('[DATA PROCESS] Cleaned data:', cleanData);
  
  // Handle scientific notation format (e.g., "1.60E-3,- 3.226E+0")
  if (cleanData.includes('E') && cleanData.includes(',')) {
    console.log('[DATA PROCESS] Found scientific notation data');
    
    // Split values and remove spaces
    const values = cleanData.split(',').map(val => val.trim());
    
    if (values.length >= 2) {
      // Process IR value (first value)
      const irValue = parseFloat(values[0]);
      const formattedIR = Math.abs(irValue * 1000).toFixed(2);  // 2 decimal places
      
      // Process Voltage value (second value)
      const voltageValue = parseFloat(values[1].replace(/[^\d.E+-]/g, ''));
      const formattedVoltage = Math.abs(voltageValue).toFixed(3);  // 3 decimal places
      
      // Check for default values (very large numbers)
      const MAX_VALID_VALUE = 1000;  // Anything above 1000 is invalid
      
      if (Math.abs(irValue) >= MAX_VALID_VALUE || Math.abs(voltageValue) >= MAX_VALID_VALUE) {
        console.log('[DATA PROCESS] Ignoring default values:', irValue, voltageValue);
        return;  // Skip sending to backend
      }
      
      latestData = {
        voltage: formattedVoltage,
        resistance: formattedIR,
        timestamp: new Date().toISOString(),
        line_no: Line_ID
      };
      
      console.log('[DATA PROCESS] Parsed measurements:', latestData);
      sendToFastAPI(latestData);
      return;
    }
  }
  
  console.log('[DATA PROCESS] Data format not recognized');
}

function processSerialData(data) {
  console.log('[DATA PROCESS] Starting data processing');
  const cleanData = data.trim();
  console.log('[DATA PROCESS] Cleaned data:', cleanData);

  if (cleanData.includes('E') && cleanData.includes(',')) {
    console.log('[DATA PROCESS] Found scientific notation data');

    const values = cleanData.split(',').map(val => val.trim());

    if (values.length >= 2) {
      const irValue = parseFloat(values[0]);
      const formattedIR = Math.abs(irValue * 1000).toFixed(2);
      
      const voltageValue = parseFloat(values[1].replace(/[^\d.E+-]/g, ''));
      const formattedVoltage = Math.abs(voltageValue).toFixed(3);

      const MAX_VALID_VALUE = 1000;

      // Case 1: Default values received
      if (Math.abs(irValue) >= MAX_VALID_VALUE || Math.abs(voltageValue) >= MAX_VALID_VALUE) {
        console.log('[DATA PROCESS] Default values detected, waiting for operator...');
        lastWasDefault = true;
        return; // Skip
      }

      // Case 2: Valid values received
      if (lastWasDefault) {
        // Accept only if last reading was default
        latestData = {
          voltage: formattedVoltage,
          resistance: formattedIR,
          timestamp: new Date().toISOString(),
          line_no: lineId
        };
        
        console.log('[DATA PROCESS] New valid measurement after default:', latestData);
        sendToFastAPI(latestData);

        lastWasDefault = false; // Reset flag
      } else {
        // Ignore continuous valid values
        console.log('[DATA PROCESS] Ignoring continuous valid measurement');
      }

      return;
    }
  }

  console.log('[DATA PROCESS] Data format not recognized');
}

/****************************
 * API ENDPOINTS
 ****************************/

// app.get('/api/measurements/latest', (req, res) => {
//   console.log('[API] GET /api/measurements/latest request received');
//   console.log('[API] Returning latest data:', latestData);
//   res.json(latestData);
// });


// Function to send data to FastAPI
async function sendToFastAPI(data) { 
  try {
    const response = await fetch('https://misapp.tataautocomp.com:5555/api/measurements', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        voltage: data.voltage,
        resistance: data.resistance,
        timestamp: new Date().toISOString(),
      }),
    });
    const result = await response.json();
    console.log('Data sent to FastAPI:', result);
  } catch (error) {
    console.error('Error sending to FastAPI:', error);
  }
}


app.post('/api/commands', async (req, res) => {
  console.log('[API] POST /api/commands request received');
  console.log('[API] Request body:', req.body);
  
  const { command } = req.body;
  if (!command) {
    console.error('[API ERROR] No command provided in request');
    return res.status(400).json({ error: 'Command is required' });
  }

  try {
    console.log(`[API] Executing command: ${command}`);
    port.write(command + '\n');
    console.log('[API] Command sent successfully');
    res.json({ success: true });
  } catch (error) {
    console.error('[API ERROR] Command execution failed:', error.message);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/reload-config', (req, res) => {
  console.log('[API] POST /api/reload-config request received');
  try {
    console.log('[API] Initiating configuration reload');
    initializeSerialPort();
    console.log('[API] Configuration reload completed successfully');
    res.json({ 
      success: true,
      message: 'COM port configuration reloaded'
    });
  } catch (error) {
    console.error('[API ERROR] Configuration reload failed:', error.message);
    res.status(500).json({ 
      success: false,
      error: error.message 
    });
  }
});

// Initialize serial port on startup
console.log('[SYSTEM] Starting serial port initialization');
initializeSerialPort();

// Start the server
const PORT = 9123;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`[SERVER] API server now running on http://192.168.0.160:${PORT}`);
  console.log('[SERVER] Available endpoints:');
  console.log(`[SERVER] GET  http://192.168.0.160:${PORT}/api/measurements/latest`);
  console.log(`[SERVER] POST http://192.168.0.160:${PORT}/api/commands`);
  console.log(`[SERVER] POST http://192.168.0.160:${PORT}/api/reload-config`);
  console.log('[SERVER] Ready to receive requests');
});
